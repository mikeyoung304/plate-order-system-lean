/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 *
 * Authentication State Caching - Enterprise Grade
 * Following original developer's patterns from transcription-cache.ts
 */

import { createClient } from '../client'
import type { Session, User } from '@supabase/supabase-js'
import type { UserProfile } from './auth-context'

export interface AuthCacheEntry {
  sessionHash: string
  user: User
  profile: UserProfile | null
  session: Session
  createdAt: Date
  lastUsed: Date
  useCount: number
  expiresAt: Date
}

export interface AuthCacheOptions {
  ttlMs?: number
  maxEntries?: number
  enablePersistence?: boolean
  enableSimilarityMatching?: boolean
}

export interface AuthCacheStats {
  memoryEntries: number
  databaseEntries: number
  hitRate: number
  missRate: number
  averageLatency: number
  oldestEntry: Date | null
  newestEntry: Date | null
}

const DEFAULT_OPTIONS: Required<AuthCacheOptions> = {
  ttlMs: 15 * 60 * 1000, // 15 minutes (shorter than transcription cache)
  maxEntries: 500, // Reasonable for auth data
  enablePersistence: true,
  enableSimilarityMatching: false, // Not needed for auth data
}

export class AuthCache {
  private memoryCache: Map<string, AuthCacheEntry> = new Map()
  private readonly options: Required<AuthCacheOptions>
  private stats = {
    hits: 0,
    misses: 0,
    totalLatency: 0,
    operations: 0,
  }

  constructor(options: AuthCacheOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options }

    // Cleanup expired entries periodically (following original pattern)
    setInterval(() => this.cleanupExpired(), 5 * 60 * 1000) // Every 5 minutes
  }

  async get(
    sessionHash: string,
    userId: string
  ): Promise<AuthCacheEntry | null> {
    const startTime = performance.now()

    try {
      // Check memory cache first (fastest)
      const entry = this.memoryCache.get(sessionHash)

      if (entry && !this.isExpired(entry)) {
        this.recordHit(startTime)
        entry.lastUsed = new Date()
        entry.useCount++

        // Update usage stats asynchronously (following original pattern)
        this.updateUsageStatsAsync(sessionHash, userId).catch(console.error)

        return entry
      }

      // Remove expired entry from memory
      if (entry && this.isExpired(entry)) {
        this.memoryCache.delete(sessionHash)
      }

      // Check database cache if persistence is enabled
      if (this.options.enablePersistence) {
        const dbEntry = await this.getFromDatabase(sessionHash)

        if (dbEntry && !this.isExpired(dbEntry)) {
          // Store in memory for faster future access
          this.memoryCache.set(sessionHash, dbEntry)
          this.recordHit(startTime)

          // Update usage stats
          dbEntry.lastUsed = new Date()
          dbEntry.useCount++
          this.updateUsageStatsAsync(sessionHash, userId).catch(console.error)

          return dbEntry
        }
      }

      this.recordMiss(startTime)
      return null
    } catch (error) {
      console.error('Error getting auth cache entry:', error)
      this.recordMiss(startTime)
      return null
    }
  }

  async set(
    sessionHash: string,
    user: User,
    profile: UserProfile | null,
    session: Session
  ): Promise<void> {
    try {
      const now = new Date()
      const entry: AuthCacheEntry = {
        sessionHash,
        user,
        profile,
        session,
        createdAt: now,
        lastUsed: now,
        useCount: 1,
        expiresAt: new Date(now.getTime() + this.options.ttlMs),
      }

      // Store in memory
      this.memoryCache.set(sessionHash, entry)

      // Enforce memory limits (following original pattern)
      if (this.memoryCache.size > this.options.maxEntries) {
        this.evictOldest()
      }

      // Store in database asynchronously if persistence is enabled
      if (this.options.enablePersistence) {
        this.persistAsync(entry).catch(console.error)
      }
    } catch (error) {
      console.error('Error setting auth cache entry:', error)
    }
  }

  async invalidate(sessionHash: string): Promise<void> {
    try {
      // Remove from memory
      this.memoryCache.delete(sessionHash)

      // Remove from database if persistence is enabled
      if (this.options.enablePersistence) {
        const supabase = createClient()
        await supabase
          .from('auth_cache')
          .delete()
          .eq('session_hash', sessionHash)
      }
    } catch (error) {
      console.error('Error invalidating auth cache entry:', error)
    }
  }

  async invalidateUser(userId: string): Promise<void> {
    try {
      // Remove all entries for user from memory
      for (const [hash, entry] of this.memoryCache.entries()) {
        if (entry.user.id === userId) {
          this.memoryCache.delete(hash)
        }
      }

      // Remove from database if persistence is enabled
      if (this.options.enablePersistence) {
        const supabase = createClient()
        await supabase.from('auth_cache').delete().eq('user_id', userId)
      }
    } catch (error) {
      console.error('Error invalidating user auth cache entries:', error)
    }
  }

  private async getFromDatabase(
    sessionHash: string
  ): Promise<AuthCacheEntry | null> {
    try {
      const supabase = createClient()
      const { data, error } = await supabase
        .from('auth_cache')
        .select('*')
        .eq('session_hash', sessionHash)
        .single()

      if (error || !data) {
        return null
      }

      return this.dbEntryToCacheEntry(data)
    } catch (error) {
      console.error('Error getting auth cache from database:', error)
      return null
    }
  }

  private async persistAsync(entry: AuthCacheEntry): Promise<void> {
    try {
      const supabase = createClient()
      const dbEntry = {
        session_hash: entry.sessionHash,
        user_id: entry.user.id,
        user_data: entry.user,
        profile_data: entry.profile,
        session_data: entry.session,
        created_at: entry.createdAt.toISOString(),
        last_used: entry.lastUsed.toISOString(),
        use_count: entry.useCount,
        expires_at: entry.expiresAt.toISOString(),
      }

      // Upsert to handle potential duplicates
      await supabase
        .from('auth_cache')
        .upsert(dbEntry, { onConflict: 'session_hash' })
    } catch (error) {
      console.error('Error persisting auth cache entry:', error)
    }
  }

  private async updateUsageStatsAsync(
    sessionHash: string,
    _userId: string
  ): Promise<void> {
    if (!this.options.enablePersistence) {
      return
    }

    try {
      const supabase = createClient()
      await supabase
        .from('auth_cache')
        .update({
          last_used: new Date().toISOString(),
          use_count: 1, // Will be updated properly in the real implementation
        })
        .eq('session_hash', sessionHash)
    } catch {
      // Don't log usage stat update errors to avoid noise
    }
  }

  private dbEntryToCacheEntry(dbEntry: any): AuthCacheEntry {
    return {
      sessionHash: dbEntry.session_hash,
      user: dbEntry.user_data,
      profile: dbEntry.profile_data,
      session: dbEntry.session_data,
      createdAt: new Date(dbEntry.created_at),
      lastUsed: new Date(dbEntry.last_used),
      useCount: dbEntry.use_count,
      expiresAt: new Date(dbEntry.expires_at),
    }
  }

  private isExpired(entry: AuthCacheEntry): boolean {
    return entry.expiresAt <= new Date()
  }

  private evictOldest(): void {
    // Find and remove the oldest entry (following original LRU pattern)
    let oldestHash: string | null = null
    let oldestTime = Date.now()

    for (const [hash, entry] of this.memoryCache.entries()) {
      if (entry.lastUsed.getTime() < oldestTime) {
        oldestTime = entry.lastUsed.getTime()
        oldestHash = hash
      }
    }

    if (oldestHash) {
      this.memoryCache.delete(oldestHash)
    }
  }

  private cleanupExpired(): void {
    const now = new Date()

    // Clean memory cache
    for (const [hash, entry] of this.memoryCache.entries()) {
      if (entry.expiresAt <= now) {
        this.memoryCache.delete(hash)
      }
    }

    // Clean database cache asynchronously
    if (this.options.enablePersistence) {
      this.cleanupExpiredFromDatabase().catch(console.error)
    }
  }

  private async cleanupExpiredFromDatabase(): Promise<void> {
    try {
      const supabase = createClient()
      await supabase
        .from('auth_cache')
        .delete()
        .lt('expires_at', new Date().toISOString())
    } catch (error) {
      console.error('Error cleaning up expired auth cache entries:', error)
    }
  }

  private recordHit(startTime: number): void {
    this.stats.hits++
    this.stats.operations++
    this.stats.totalLatency += performance.now() - startTime
  }

  private recordMiss(startTime: number): void {
    this.stats.misses++
    this.stats.operations++
    this.stats.totalLatency += performance.now() - startTime
  }

  async getStats(): Promise<AuthCacheStats> {
    const hitRate =
      this.stats.operations > 0 ? this.stats.hits / this.stats.operations : 0
    const averageLatency =
      this.stats.operations > 0
        ? this.stats.totalLatency / this.stats.operations
        : 0

    let databaseEntries = 0
    let oldestEntry: Date | null = null
    let newestEntry: Date | null = null

    // Get database stats if persistence is enabled
    if (this.options.enablePersistence) {
      try {
        const supabase = createClient()
        const { count } = await supabase
          .from('auth_cache')
          .select('*', { count: 'exact', head: true })

        databaseEntries = count || 0

        // Get oldest and newest entries
        const { data: oldest } = await supabase
          .from('auth_cache')
          .select('created_at')
          .order('created_at', { ascending: true })
          .limit(1)
          .single()

        const { data: newest } = await supabase
          .from('auth_cache')
          .select('created_at')
          .order('created_at', { ascending: false })
          .limit(1)
          .single()

        if (oldest) {
          oldestEntry = new Date(oldest.created_at)
        }
        if (newest) {
          newestEntry = new Date(newest.created_at)
        }
      } catch (error) {
        console.error('Error getting database cache stats:', error)
      }
    }

    return {
      memoryEntries: this.memoryCache.size,
      databaseEntries,
      hitRate,
      missRate: 1 - hitRate,
      averageLatency,
      oldestEntry,
      newestEntry,
    }
  }

  // Generate session hash for caching (simple but effective)
  static generateSessionHash(session: Session): string {
    return `${session.user.id}_${session.access_token.slice(-8)}_${Math.floor(session.expires_at || 0)}`
  }

  // Clear all cache entries (for testing/debugging)
  async clear(): Promise<void> {
    this.memoryCache.clear()

    if (this.options.enablePersistence) {
      try {
        const supabase = createClient()
        await supabase.from('auth_cache').delete().neq('id', 'impossible-id')
      } catch (error) {
        console.error('Error clearing database cache:', error)
      }
    }
  }
}

// Singleton instance (following original pattern)
let cacheInstance: AuthCache | null = null

export function getAuthCache(options?: AuthCacheOptions): AuthCache {
  if (!cacheInstance) {
    cacheInstance = new AuthCache(options)
  }
  return cacheInstance
}

// Convenience methods for common operations
export async function getCachedAuth(
  sessionHash: string,
  userId: string
): Promise<AuthCacheEntry | null> {
  const cache = getAuthCache()
  return await cache.get(sessionHash, userId)
}

export async function setCachedAuth(
  sessionHash: string,
  user: User,
  profile: UserProfile | null,
  session: Session
): Promise<void> {
  const cache = getAuthCache()
  await cache.set(sessionHash, user, profile, session)
}

export async function invalidateCachedAuth(sessionHash: string): Promise<void> {
  const cache = getAuthCache()
  await cache.invalidate(sessionHash)
}

export async function invalidateUserAuth(userId: string): Promise<void> {
  const cache = getAuthCache()
  await cache.invalidateUser(userId)
}
