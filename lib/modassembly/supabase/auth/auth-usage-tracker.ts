/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 *
 * Authentication Usage Tracking - Enterprise Grade
 * Following original developer's patterns from usage-tracking.ts
 */

import { createClient } from '../client'
// Auth usage tracking types

export interface AuthMetrics {
  id: string
  userId: string
  operation:
    | 'login'
    | 'logout'
    | 'token_refresh'
    | 'session_check'
    | 'permission_check'
    | 'profile_fetch'
  authMethod: 'password' | 'oauth' | 'session' | 'api_key' | 'demo'
  success: boolean
  cached: boolean
  timestamp: Date
  metadata: {
    retryCount?: number
    errorCode?: string
    latency?: number
    ipAddress?: string
    userAgent?: string
    sessionDuration?: number
    redirectCount?: number
    cacheHitType?: 'memory' | 'database' | 'none'
  }
}

export interface AuthUsageStats {
  period: 'hour' | 'day' | 'week' | 'month'
  totalRequests: number
  successfulRequests: number
  failedRequests: number
  cacheHitRate: number
  avgLatency: number
  operationBreakdown: Record<string, number>
  errorBreakdown: Record<string, number>
  topUsers: Array<{ userId: string; requestCount: number; successRate: number }>
}

export interface AuthAlert {
  type:
    | 'high_failure_rate'
    | 'slow_response'
    | 'security_concern'
    | 'cache_miss_rate'
  severity: 'warning' | 'critical'
  threshold: number
  current: number
  message: string
  recommendations: string[]
}

export class AuthUsageTracker {
  private batchedMetrics: AuthMetrics[] = []
  private readonly batchSize = 10
  private readonly batchTimeoutMs = 30000
  private readonly maxMemoryEntries = 1000
  private isProcessing = false

  constructor() {
    // Start batch processing timer (following original pattern)
    setInterval(() => this.flushBatch(), this.batchTimeoutMs)

    // Cleanup old memory entries periodically
    setInterval(() => this.cleanupMemory(), 5 * 60 * 1000) // Every 5 minutes
  }

  async recordAuthOperation(params: {
    userId: string
    operation: AuthMetrics['operation']
    authMethod: AuthMetrics['authMethod']
    success: boolean
    cached?: boolean
    metadata?: AuthMetrics['metadata']
  }): Promise<void> {
    const metrics: AuthMetrics = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      cached: params.cached || false,
      ...params,
      metadata: {
        ...params.metadata,
        retryCount: params.metadata?.retryCount || 0,
      },
    }

    await this.addToBatch(metrics)

    // Record critical failures immediately for alerting
    if (
      !params.success &&
      this.isCriticalFailure(params.operation, params.metadata?.errorCode)
    ) {
      await this.recordCriticalFailure(metrics)
    }
  }

  private async addToBatch(metrics: AuthMetrics): Promise<void> {
    this.batchedMetrics.push(metrics)

    if (this.batchedMetrics.length >= this.batchSize) {
      await this.flushBatch()
    }
  }

  private async flushBatch(): Promise<void> {
    if (this.batchedMetrics.length === 0 || this.isProcessing) {
      return
    }

    this.isProcessing = true

    try {
      const batch = [...this.batchedMetrics]
      this.batchedMetrics = []

      // Transform to database format (following original pattern)
      const dbRecords = batch.map(metrics => ({
        id: metrics.id,
        user_id: metrics.userId,
        operation: metrics.operation,
        auth_method: metrics.authMethod,
        success: metrics.success,
        cached: metrics.cached,
        created_at: metrics.timestamp.toISOString(),
        metadata: metrics.metadata,
      }))

      const supabase = createClient()
      const { error } = await supabase
        .from('auth_usage_metrics')
        .insert(dbRecords)

      if (error) {
        console.error('Failed to flush auth metrics batch:', error)
        // Re-add failed metrics to front of batch for retry (original pattern)
        this.batchedMetrics.unshift(...batch)
      }
    } catch (error) {
      console.error('Error flushing auth metrics:', error)
      // Keep metrics for retry on next flush
    } finally {
      this.isProcessing = false
    }
  }

  async getUsageStats(
    period: AuthUsageStats['period']
  ): Promise<AuthUsageStats> {
    const supabase = createClient()

    let dateFilter: string
    const now = new Date()

    switch (period) {
      case 'hour':
        dateFilter = new Date(now.getTime() - 60 * 60 * 1000).toISOString()
        break
      case 'day':
        dateFilter = new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString()
        break
      case 'week':
        dateFilter = new Date(
          now.getTime() - 7 * 24 * 60 * 60 * 1000
        ).toISOString()
        break
      case 'month':
        dateFilter = new Date(
          now.getTime() - 30 * 24 * 60 * 60 * 1000
        ).toISOString()
        break
    }

    const { data: metrics, error } = await supabase
      .from('auth_usage_metrics')
      .select('*')
      .gte('created_at', dateFilter)

    if (error) {
      throw new Error(`Failed to fetch auth usage stats: ${error.message}`)
    }

    return this.calculateStats(metrics || [], period)
  }

  private calculateStats(
    metrics: any[],
    period: AuthUsageStats['period']
  ): AuthUsageStats {
    const totalRequests = metrics.length
    const successfulRequests = metrics.filter(m => m.success).length
    const cacheHits = metrics.filter(m => m.cached).length
    const cacheHitRate = totalRequests > 0 ? cacheHits / totalRequests : 0

    // Calculate average latency (following original pattern)
    const latencies = metrics
      .map(m => m.metadata?.latency)
      .filter(l => typeof l === 'number') as number[]
    const avgLatency =
      latencies.length > 0
        ? latencies.reduce((sum, l) => sum + l, 0) / latencies.length
        : 0

    // Operation breakdown
    const operationBreakdown = metrics.reduce(
      (acc, m) => {
        acc[m.operation] = (acc[m.operation] || 0) + 1
        return acc
      },
      {} as Record<string, number>
    )

    // Error breakdown
    const errorBreakdown = metrics
      .filter(m => !m.success && m.metadata?.errorCode)
      .reduce(
        (acc, m) => {
          const errorCode = m.metadata.errorCode
          acc[errorCode] = (acc[errorCode] || 0) + 1
          return acc
        },
        {} as Record<string, number>
      )

    // Top users by request count
    const userStats = metrics.reduce(
      (acc, m) => {
        if (!acc[m.user_id]) {
          acc[m.user_id] = { requestCount: 0, successCount: 0 }
        }
        acc[m.user_id].requestCount++
        if (m.success) {
          acc[m.user_id].successCount++
        }
        return acc
      },
      {} as Record<string, { requestCount: number; successCount: number }>
    )

    const topUsers = Object.entries(userStats)
      .map(
        ([userId, stats]: [
          string,
          { requestCount: number; successCount: number },
        ]) => ({
          userId,
          requestCount: stats.requestCount,
          successRate:
            stats.requestCount > 0
              ? stats.successCount / stats.requestCount
              : 0,
        })
      )
      .sort((a, b) => b.requestCount - a.requestCount)
      .slice(0, 10)

    return {
      period,
      totalRequests,
      successfulRequests,
      failedRequests: totalRequests - successfulRequests,
      cacheHitRate,
      avgLatency,
      operationBreakdown,
      errorBreakdown,
      topUsers,
    }
  }

  async checkAuthAlerts(): Promise<AuthAlert[]> {
    const alerts: AuthAlert[] = []
    const hourlyStats = await this.getUsageStats('hour')
    const _dailyStats = await this.getUsageStats('day')

    // High failure rate alert (following original threshold pattern)
    const failureRate =
      hourlyStats.totalRequests > 0
        ? hourlyStats.failedRequests / hourlyStats.totalRequests
        : 0

    if (failureRate > 0.1 && hourlyStats.totalRequests >= 10) {
      alerts.push({
        type: 'high_failure_rate',
        severity: failureRate > 0.3 ? 'critical' : 'warning',
        threshold: 0.1,
        current: failureRate,
        message: `Auth failure rate is ${Math.round(failureRate * 100)}% in the last hour`,
        recommendations: [
          'Check database connectivity',
          'Verify authentication service health',
          'Review recent error codes in breakdown',
        ],
      })
    }

    // Slow response alert
    if (hourlyStats.avgLatency > 2000 && hourlyStats.totalRequests >= 5) {
      alerts.push({
        type: 'slow_response',
        severity: hourlyStats.avgLatency > 5000 ? 'critical' : 'warning',
        threshold: 2000,
        current: hourlyStats.avgLatency,
        message: `Average auth latency is ${Math.round(hourlyStats.avgLatency)}ms`,
        recommendations: [
          'Check database query performance',
          'Review auth cache hit rate',
          'Consider auth state optimization',
        ],
      })
    }

    // Cache miss rate alert
    if (hourlyStats.cacheHitRate < 0.3 && hourlyStats.totalRequests >= 20) {
      alerts.push({
        type: 'cache_miss_rate',
        severity: hourlyStats.cacheHitRate < 0.1 ? 'critical' : 'warning',
        threshold: 0.3,
        current: hourlyStats.cacheHitRate,
        message: `Auth cache hit rate is ${Math.round(hourlyStats.cacheHitRate * 100)}%`,
        recommendations: [
          'Review cache TTL settings',
          'Check cache invalidation logic',
          'Consider increasing cache size',
        ],
      })
    }

    // Security concern alert (multiple failed logins)
    const recentFailedLogins = Object.entries(hourlyStats.errorBreakdown)
      .filter(([errorCode]) => errorCode.includes('INVALID_CREDENTIALS'))
      .reduce((sum, [, count]) => sum + count, 0)

    if (recentFailedLogins > 50) {
      alerts.push({
        type: 'security_concern',
        severity: recentFailedLogins > 100 ? 'critical' : 'warning',
        threshold: 50,
        current: recentFailedLogins,
        message: `${recentFailedLogins} failed login attempts in the last hour`,
        recommendations: [
          'Review failed login patterns',
          'Consider implementing rate limiting',
          'Check for potential brute force attacks',
        ],
      })
    }

    return alerts
  }

  private isCriticalFailure(operation: string, errorCode?: string): boolean {
    // Define critical failures that need immediate attention
    const criticalErrors = [
      'DATABASE_CONNECTION_FAILED',
      'AUTH_SERVICE_UNAVAILABLE',
      'SECURITY_VIOLATION',
      'INFINITE_REDIRECT_DETECTED',
    ]

    return (
      criticalErrors.includes(errorCode || '') ||
      (operation === 'login' && errorCode === 'SYSTEM_ERROR')
    )
  }

  private async recordCriticalFailure(metrics: AuthMetrics): Promise<void> {
    // Immediate logging for critical failures
    console.error('CRITICAL AUTH FAILURE:', {
      operation: metrics.operation,
      errorCode: metrics.metadata.errorCode,
      userId: metrics.userId,
      timestamp: metrics.timestamp,
    })

    // Could integrate with external alerting systems here
  }

  private cleanupMemory(): void {
    // Keep memory usage reasonable (following original pattern)
    if (this.batchedMetrics.length > this.maxMemoryEntries) {
      this.batchedMetrics = this.batchedMetrics.slice(
        -this.maxMemoryEntries / 2
      )
    }
  }

  // Cleanup method for graceful shutdown
  async cleanup(): Promise<void> {
    await this.flushBatch()
  }
}

// Singleton instance (following original pattern)
let trackerInstance: AuthUsageTracker | null = null

export function getAuthUsageTracker(): AuthUsageTracker {
  if (!trackerInstance) {
    trackerInstance = new AuthUsageTracker()
  }
  return trackerInstance
}

// Convenience method for simple usage tracking
export async function trackAuthOperation(params: {
  userId: string
  operation: AuthMetrics['operation']
  authMethod: AuthMetrics['authMethod']
  success: boolean
  startTime?: number
  cached?: boolean
  errorCode?: string
  retryCount?: number
}): Promise<void> {
  const tracker = getAuthUsageTracker()
  const latency = params.startTime ? Date.now() - params.startTime : undefined

  await tracker.recordAuthOperation({
    ...params,
    metadata: {
      latency,
      errorCode: params.errorCode,
      retryCount: params.retryCount,
      userAgent:
        typeof window !== 'undefined' ? window.navigator.userAgent : undefined,
    },
  })
}
