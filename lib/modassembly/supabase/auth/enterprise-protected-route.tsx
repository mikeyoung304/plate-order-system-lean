/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 *
 * Enterprise Protected Route - Production Ready
 * Following original developer's patterns with comprehensive error handling
 */

'use client'

import { useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { useAuth, useAuthStatus, useHasRole } from './enterprise-auth-context'
import { trackAuthOperation } from './auth-usage-tracker'
import type { UserRole } from '@/types/database'

interface ProtectedRouteProps {
  children: React.ReactNode
  roles?: UserRole | UserRole[]
  redirectTo?: string
  fallback?: React.ReactNode
  maxRetries?: number
  retryDelay?: number
  requireProfile?: boolean
}

interface RouteState {
  status: 'checking' | 'authorized' | 'unauthorized' | 'error' | 'redirecting'
  error?: string
  retryCount: number
}

export function ProtectedRoute({
  children,
  roles,
  redirectTo = '/',
  fallback,
  maxRetries = 3,
  retryDelay = 1000,
  requireProfile = true,
}: ProtectedRouteProps) {
  const router = useRouter()
  const { user, profile } = useAuth()
  const authStatus = useAuthStatus()
  const [routeState, setRouteState] = useState<RouteState>({
    status: 'checking',
    retryCount: 0,
  })

  // Calculate role permissions (following original pattern - always call hooks)
  const hasRequiredRole = useHasRole(roles || 'server')
  const finalHasRole = roles ? hasRequiredRole : true

  // Route authorization logic with enterprise error handling
  const checkAuthorization = useCallback(async () => {
    const startTime = Date.now()

    try {
      setRouteState(prev => ({ ...prev, status: 'checking', error: undefined }))

      // Wait for auth initialization to complete
      if (authStatus.isInitializing || authStatus.isLoading) {
        return // Stay in checking state
      }

      // Handle auth errors with retry logic
      if (authStatus.hasError) {
        if (routeState.retryCount < maxRetries) {
          console.warn(
            `Auth error detected, retrying in ${retryDelay}ms (attempt ${routeState.retryCount + 1}/${maxRetries})`
          )

          setRouteState(prev => ({
            ...prev,
            retryCount: prev.retryCount + 1,
          }))

          setTimeout(
            () => {
              // Trigger auth refresh
              checkAuthorization()
            },
            retryDelay * Math.pow(2, routeState.retryCount)
          )

          return
        } else {
          setRouteState({
            status: 'error',
            error: authStatus.error || 'Authentication failed after retries',
            retryCount: routeState.retryCount,
          })
          return
        }
      }

      // Check if user is authenticated
      if (!authStatus.isAuthenticated || !user) {
        setRouteState({ status: 'unauthorized', retryCount: 0 })

        // Track unauthorized access attempt
        await trackAuthOperation({
          userId: user?.id || 'anonymous',
          operation: 'permission_check',
          authMethod: 'session',
          success: false,
          startTime,
          errorCode: 'NOT_AUTHENTICATED',
        })

        // Redirect to login
        setRouteState(prev => ({ ...prev, status: 'redirecting' }))
        router.push(redirectTo)
        return
      }

      // Check if profile is required and available
      if (requireProfile && roles && !profile) {
        // Profile is still loading, wait
        return
      }

      // Check role permissions
      if (roles && !finalHasRole) {
        setRouteState({ status: 'unauthorized', retryCount: 0 })

        // Track unauthorized role access attempt
        await trackAuthOperation({
          userId: user.id,
          operation: 'permission_check',
          authMethod: 'session',
          success: false,
          startTime,
          errorCode: 'INSUFFICIENT_PERMISSIONS',
          retryCount: 0,
        })

        // Redirect to dashboard (user is authenticated but lacks permission)
        setRouteState(prev => ({ ...prev, status: 'redirecting' }))
        router.push('/dashboard')
        return
      }

      // Authorization successful
      setRouteState({ status: 'authorized', retryCount: 0 })

      // Track successful authorization
      await trackAuthOperation({
        userId: user.id,
        operation: 'permission_check',
        authMethod: 'session',
        success: true,
        startTime,
        retryCount: 0,
      })
    } catch (error) {
      console.error('Route authorization error:', error)
      setRouteState({
        status: 'error',
        error:
          error instanceof Error
            ? error.message
            : 'Unknown authorization error',
        retryCount: routeState.retryCount,
      })

      // Track authorization error
      if (user) {
        await trackAuthOperation({
          userId: user.id,
          operation: 'permission_check',
          authMethod: 'session',
          success: false,
          startTime,
          errorCode: 'AUTHORIZATION_ERROR',
        })
      }
    }
  }, [
    authStatus,
    user,
    profile,
    roles,
    finalHasRole,
    requireProfile,
    routeState.retryCount,
    maxRetries,
    retryDelay,
    redirectTo,
    router,
  ])

  // Run authorization check when dependencies change
  useEffect(() => {
    checkAuthorization()
  }, [checkAuthorization])

  // Render based on route state
  switch (routeState.status) {
    case 'checking':
      return (
        fallback || (
          <div className='flex items-center justify-center min-h-screen bg-gray-900'>
            <div className='text-center'>
              <div className='animate-spin rounded-full h-12 w-12 border-b-2 border-teal-400 mx-auto mb-4'></div>
              <p className='text-gray-400 text-sm'>
                {authStatus.isInitializing
                  ? 'Initializing authentication...'
                  : authStatus.isLoading
                    ? 'Verifying access...'
                    : 'Checking permissions...'}
              </p>
              {routeState.retryCount > 0 && (
                <p className='text-gray-500 text-xs mt-2'>
                  Retry {routeState.retryCount}/{maxRetries}
                </p>
              )}
            </div>
          </div>
        )
      )

    case 'error':
      return (
        <div className='flex items-center justify-center min-h-screen bg-gray-900'>
          <div className='text-center max-w-md p-6'>
            <div className='text-red-400 text-6xl mb-4'>⚠️</div>
            <h2 className='text-xl font-semibold text-white mb-2'>
              Access Error
            </h2>
            <p className='text-gray-400 text-sm mb-4'>
              {routeState.error ||
                'Unable to verify your access. Please try again.'}
            </p>
            <div className='space-x-4'>
              <button
                onClick={() => {
                  setRouteState({ status: 'checking', retryCount: 0 })
                  checkAuthorization()
                }}
                className='bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded-md text-sm'
              >
                Retry
              </button>
              <button
                onClick={() => router.push('/')}
                className='bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm'
              >
                Go Home
              </button>
            </div>
          </div>
        </div>
      )

    case 'authorized':
      return <>{children}</>

    case 'unauthorized':
    case 'redirecting':
      // Show loading during redirect to prevent flash
      return (
        <div className='flex items-center justify-center min-h-screen bg-gray-900'>
          <div className='text-center'>
            <div className='animate-spin rounded-full h-8 w-8 border-b-2 border-gray-400 mx-auto mb-4'></div>
            <p className='text-gray-500 text-sm'>Redirecting...</p>
          </div>
        </div>
      )

    default:
      return null
  }
}

// Server-side protected route for app router (following original pattern)
interface ServerProtectedRouteProps {
  children: React.ReactNode
  roles?: UserRole | UserRole[]
}

export async function ServerProtectedRoute({
  children,
  roles,
}: ServerProtectedRouteProps) {
  const { redirect } = await import('next/navigation')
  const { getUserWithProfile } = await import('./session')

  // Import role checking dynamically to avoid circular dependencies
  const { hasRole } = await import('./roles')

  const userWithProfile = await getUserWithProfile()

  if (!userWithProfile) {
    redirect('/')
  }

  if (roles) {
    const hasRequiredRole = await hasRole(roles)
    if (!hasRequiredRole) {
      redirect('/dashboard')
    }
  }

  return <>{children}</>
}

// Export aliases for compatibility
export { ProtectedRoute as EnterpriseProtectedRoute }
export { ProtectedRoute as default }
