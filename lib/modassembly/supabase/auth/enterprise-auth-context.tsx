/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 *
 * Enterprise Authentication Context - Production Ready
 * Following original developer's patterns with enterprise features
 */

'use client'

import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from 'react'
import { createClient } from '@/lib/modassembly/supabase/client'
import type { Session, User } from '@supabase/supabase-js'
import { UserRole } from '@/types/database'
import { isDemoUser } from '@/lib/demo'
import { getAuthUsageTracker, trackAuthOperation } from './auth-usage-tracker'
import { AuthCache, getAuthCache } from './auth-cache'

export type UserProfile = {
  user_id: string
  role: UserRole
  name: string | null
}

interface AuthState {
  status:
    | 'initializing'
    | 'loading'
    | 'authenticated'
    | 'unauthenticated'
    | 'error'
  user: User | null
  profile: UserProfile | null
  session: Session | null
  error: string | null
}

interface AuthContextType extends AuthState {
  signOut: () => Promise<void>
  refreshAuth: () => Promise<void>
  isLoading: boolean
}

interface AuthOptions {
  enableCaching?: boolean
  enableMonitoring?: boolean
  maxRetries?: number
  retryDelay?: number
}

interface AuthError extends Error {
  code:
    | 'SESSION_FETCH_FAILED'
    | 'PROFILE_FETCH_FAILED'
    | 'AUTH_INITIALIZATION_FAILED'
    | 'AUTH_SERVICE_UNAVAILABLE'
  retryable: boolean
  details?: any
}

const DEFAULT_OPTIONS: Required<AuthOptions> = {
  enableCaching: true,
  enableMonitoring: true,
  maxRetries: 3,
  retryDelay: 1000,
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function EnterpriseAuthProvider({
  children,
  options = {},
}: {
  children: React.ReactNode
  options?: AuthOptions
}) {
  const [authState, setAuthState] = useState<AuthState>({
    status: 'initializing',
    user: null,
    profile: null,
    session: null,
    error: null,
  })

  const finalOptions = { ...DEFAULT_OPTIONS, ...options }
  const cache = finalOptions.enableCaching ? getAuthCache() : null
  const tracker = finalOptions.enableMonitoring ? getAuthUsageTracker() : null

  // Centralized profile fetching with enterprise error handling
  const fetchUserProfile = useCallback(
    async (
      userId: string,
      supabaseClient: ReturnType<typeof createClient>,
      retryCount = 0
    ): Promise<UserProfile | null> => {
      const startTime = Date.now()
      const maxRetries = finalOptions.maxRetries
      const backoffDelay = finalOptions.retryDelay * Math.pow(2, retryCount)

      try {
        const { data: profile, error } = await supabaseClient
          .from('profiles')
          .select('user_id, role, name')
          .eq('user_id', userId)
          .single()

        if (error) {
          throw createAuthError('PROFILE_FETCH_FAILED', error.message, true)
        }

        const userProfile = profile
          ? {
              user_id: profile.user_id || userId,
              role: profile.role,
              name: profile.name,
            }
          : null

        // Track successful operation
        if (tracker) {
          await trackAuthOperation({
            userId,
            operation: 'profile_fetch',
            authMethod: 'session',
            success: true,
            startTime,
            cached: false,
          })
        }

        return userProfile
      } catch (error) {
        const authError = normalizeError(error)

        // Track failed operation
        if (tracker) {
          await trackAuthOperation({
            userId,
            operation: 'profile_fetch',
            authMethod: 'session',
            success: false,
            startTime,
            errorCode: authError.code,
            retryCount,
          })
        }

        // Retry logic with exponential backoff (following original pattern)
        if (authError.retryable && retryCount < maxRetries) {
          console.warn(
            `Profile fetch failed, retrying in ${backoffDelay}ms (attempt ${retryCount + 1}/${maxRetries})`
          )
          await new Promise(resolve => setTimeout(resolve, backoffDelay))
          return fetchUserProfile(userId, supabaseClient, retryCount + 1)
        }

        console.error('Profile fetch failed after all retries:', authError)
        return null
      }
    },
    [
      finalOptions.maxRetries,
      finalOptions.retryDelay,
      tracker,
      createAuthError,
      normalizeError,
    ]
  )

  // Create auth error with proper classification
  const createAuthError = useCallback(
    (
      code: AuthError['code'],
      message: string,
      retryable: boolean,
      details?: any
    ): AuthError => {
      const error = new Error(message) as AuthError
      error.code = code
      error.retryable = retryable
      error.details = details
      return error
    },
    []
  )

  // Normalize various error types into AuthError (following original pattern)
  const normalizeError = useCallback(
    (error: any): AuthError => {
      if (error.code && error.retryable !== undefined) {
        return error as AuthError
      }

      const message = error.message || error.toString()

      // Network errors are retryable
      if (
        message.includes('fetch') ||
        message.includes('network') ||
        message.includes('timeout')
      ) {
        return createAuthError(
          'AUTH_SERVICE_UNAVAILABLE',
          'Auth service temporarily unavailable',
          true
        )
      }

      // Database connection errors are retryable
      if (message.includes('connection') || message.includes('database')) {
        return createAuthError(
          'PROFILE_FETCH_FAILED',
          'Database connection failed',
          true
        )
      }

      // Default to non-retryable
      return createAuthError('AUTH_INITIALIZATION_FAILED', message, false)
    },
    [createAuthError]
  )

  // Comprehensive auth initialization with caching
  const initializeAuth = useCallback(async (): Promise<void> => {
    const mounted = true
    const startTime = Date.now()

    try {
      setAuthState(prev => ({ ...prev, status: 'loading', error: null }))

      const supabase = createClient()
      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession()

      if (sessionError) {
        throw createAuthError(
          'SESSION_FETCH_FAILED',
          sessionError.message,
          true
        )
      }

      if (!mounted) {
        return
      }

      if (session?.user) {
        const sessionHash = cache
          ? AuthCache.generateSessionHash(session)
          : null
        let cachedAuth = null

        // Check cache first if enabled
        if (cache && sessionHash) {
          cachedAuth = await cache.get(sessionHash, session.user.id)
        }

        if (cachedAuth && !mounted) {
          return
        }

        let userProfile: UserProfile | null = null

        if (cachedAuth) {
          // Use cached data
          userProfile = cachedAuth.profile

          if (tracker) {
            await trackAuthOperation({
              userId: session.user.id,
              operation: 'session_check',
              authMethod: 'session',
              success: true,
              startTime,
              cached: true,
            })
          }
        } else {
          // Fetch fresh profile data
          userProfile = await fetchUserProfile(session.user.id, supabase)

          // Cache the result if caching is enabled
          if (cache && sessionHash && userProfile) {
            await cache.set(sessionHash, session.user, userProfile, session)
          }
        }

        if (mounted) {
          setAuthState({
            status: 'authenticated',
            user: session.user,
            profile: userProfile,
            session,
            error: null,
          })
        }
      } else {
        if (mounted) {
          setAuthState({
            status: 'unauthenticated',
            user: null,
            profile: null,
            session: null,
            error: null,
          })
        }

        if (tracker) {
          await trackAuthOperation({
            userId: 'anonymous',
            operation: 'session_check',
            authMethod: 'session',
            success: true,
            startTime,
          })
        }
      }
    } catch (error) {
      const authError = normalizeError(error)
      console.error('Auth initialization failed:', authError)

      if (mounted) {
        setAuthState({
          status: 'error',
          user: null,
          profile: null,
          session: null,
          error: authError.message,
        })
      }
    }
  }, [cache, tracker, fetchUserProfile, createAuthError, normalizeError])

  // Manual auth refresh with enterprise features
  const refreshAuth = useCallback(async (): Promise<void> => {
    await initializeAuth()
  }, [initializeAuth])

  // Sign out with cache invalidation
  const signOut = useCallback(async (): Promise<void> => {
    const startTime = Date.now()

    try {
      const supabase = createClient()
      const currentSession = authState.session

      await supabase.auth.signOut()

      // Invalidate cache if enabled
      if (cache && currentSession) {
        const sessionHash = AuthCache.generateSessionHash(currentSession)
        await cache.invalidate(sessionHash)
      }

      setAuthState({
        status: 'unauthenticated',
        user: null,
        profile: null,
        session: null,
        error: null,
      })

      if (tracker && authState.user) {
        await trackAuthOperation({
          userId: authState.user.id,
          operation: 'logout',
          authMethod: 'session',
          success: true,
          startTime,
        })
      }
    } catch (error) {
      console.error('Sign out failed:', error)

      if (tracker && authState.user) {
        await trackAuthOperation({
          userId: authState.user.id,
          operation: 'logout',
          authMethod: 'session',
          success: false,
          startTime,
          errorCode: 'LOGOUT_FAILED',
        })
      }
    }
  }, [authState.session, authState.user, cache, tracker])

  // Initialize auth on mount
  useEffect(() => {
    let mounted = true
    const supabase = createClient()

    // Initial auth check
    initializeAuth()

    // Set up auth state listener with enterprise error handling
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      if (!mounted) {
        return
      }

      try {
        setAuthState(prev => ({ ...prev, status: 'loading', error: null }))

        if (session?.user) {
          const userProfile = await fetchUserProfile(session.user.id, supabase)

          if (mounted) {
            setAuthState({
              status: 'authenticated',
              user: session.user,
              profile: userProfile,
              session,
              error: null,
            })

            // Cache the new session if enabled
            if (cache) {
              const sessionHash = AuthCache.generateSessionHash(session)
              await cache.set(sessionHash, session.user, userProfile, session)
            }
          }
        } else {
          if (mounted) {
            setAuthState({
              status: 'unauthenticated',
              user: null,
              profile: null,
              session: null,
              error: null,
            })
          }
        }
      } catch (error) {
        const authError = normalizeError(error)
        console.error('Auth state change error:', authError)

        if (mounted) {
          setAuthState({
            status: 'error',
            user: null,
            profile: null,
            session: null,
            error: authError.message,
          })
        }
      }
    })

    return () => {
      mounted = false
      subscription.unsubscribe()
    }
  }, [initializeAuth, fetchUserProfile, cache, normalizeError])

  const value: AuthContextType = {
    ...authState,
    isLoading:
      authState.status === 'initializing' || authState.status === 'loading',
    signOut,
    refreshAuth,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

// Hook with error handling
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an EnterpriseAuthProvider')
  }
  return context
}

// Convenience hooks (following original pattern)
export function useUser(): User | null {
  const { user } = useAuth()
  return user
}

export function useProfile(): UserProfile | null {
  const { profile } = useAuth()
  return profile
}

export function useRole(): UserRole | null {
  const { profile } = useAuth()
  return profile?.role || null
}

export function useIsRole(role: UserRole): boolean {
  const userRole = useRole()
  return userRole === role
}

// Enhanced role checking with demo user support (following original pattern)
export function useHasRole(roles: UserRole | UserRole[]): boolean {
  const { user, profile } = useAuth()

  // Check if this is the demo user (following original demo pattern)
  if (user?.email && isDemoUser(user.email)) {
    return true
  }

  if (!profile?.role) {
    return false
  }

  const allowedRoles = Array.isArray(roles) ? roles : [roles]
  return allowedRoles.includes(profile.role)
}

// Auth status helpers
export function useAuthStatus() {
  const { status, error, isLoading } = useAuth()

  return {
    isInitializing: status === 'initializing',
    isLoading: isLoading,
    isAuthenticated: status === 'authenticated',
    isUnauthenticated: status === 'unauthenticated',
    hasError: status === 'error',
    error,
  }
}

// Export the provider with original name for compatibility
export { EnterpriseAuthProvider as AuthProvider }
