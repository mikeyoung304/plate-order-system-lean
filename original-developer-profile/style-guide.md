# Style Guide - Original Developer's Coding Standards

## Overview
This document captures the original developer's consistent coding style, naming conventions, and formatting preferences extracted from all mod assembly implementations.

## File and Directory Organization

### 1. Hierarchical Module Structure
```
lib/modassembly/
├── supabase/              # Backend integration
│   ├── auth/              # Authentication subsystem
│   ├── database/          # Data access layer
│   └── {client,server}.ts # Core connection modules
├── openai/                # AI service integration
│   ├── optimized-*.ts     # Enhanced versions
│   ├── *-cache.ts         # Caching modules
│   └── usage-tracking.ts  # Monitoring module
└── audio-recording/       # Media processing
    └── audio-optimization.ts
```

**Principles**:
- Group by domain/service, not by file type
- Keep related functionality together
- Clear separation between base and enhanced versions

### 2. File Naming Conventions

#### Module Files
```typescript
// Base modules: simple descriptive names
client.ts
server.ts
auth-context.tsx
roles.ts

// Enhanced modules: prefix with optimization type
optimized-client.ts
optimized-transcribe.ts
server-production.ts

// Utility modules: suffix with purpose
transcription-cache.ts
usage-tracking.ts
audio-optimization.ts

// React components: PascalCase with descriptive names
AuthForm.tsx
KDSHeader.tsx
DemoModeIndicator.tsx
```

#### Patterns Observed
- **Base functionality**: `{feature}.ts`
- **Optimized versions**: `optimized-{feature}.ts` or `{feature}-optimized.ts`
- **Caching modules**: `{feature}-cache.ts`
- **Monitoring modules**: `{feature}-tracking.ts` or `usage-tracking.ts`
- **React components**: `{ComponentName}.tsx`
- **Context providers**: `{feature}-context.tsx`

## Code Structure and Organization

### 1. File Header Pattern
```typescript
/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

// OR for modified files:

/**
 * MODASSEMBLY CHANGE LOG
 * Date: 2024-01-30
 * File: suggestions.ts
 * Change: Complete rewrite - removed security theater and AI bloat
 * Reason: Original was AI-generated code with fake "professional" security
 * Impact: Much simpler, faster, more maintainable suggestion algorithm
 * Risk: Low - same functionality, cleaner implementation
 */
```

**Pattern**: Always document file purpose and significant changes

### 2. Import Organization
```typescript
// 1. React/Next.js imports
import React, { useActionState, useTransition, useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'

// 2. Third-party libraries
import OpenAI from 'openai'

// 3. UI components (grouped by source)
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'

// 4. Local utilities and services
import { createClient } from '@/lib/modassembly/supabase/client'
import { getUsageTracker } from './usage-tracking'

// 5. Types and interfaces
import type { TranscriptionOptions, TranscriptionResult } from './types'
```

**Order**:
1. Framework imports
2. Third-party libraries
3. UI components (grouped)
4. Local modules
5. Types and interfaces

### 3. Interface and Type Definitions

#### Comprehensive Interface Pattern
```typescript
export interface UsageMetrics {
  // Required fields first
  id: string
  userId: string
  operation: 'transcription' | 'chat_completion' | 'batch_processing'
  model: string
  cost: number
  cached: boolean
  optimized: boolean
  timestamp: Date
  
  // Optional fields with specific types
  inputTokens?: number
  outputTokens?: number
  audioDuration?: number
  
  // Metadata object for extensibility
  metadata: {
    fileSize?: number
    compressionRatio?: number
    confidence?: number
    retryCount?: number
    errorCode?: string
    latency?: number
  }
}
```

#### Error Type Pattern
```typescript
export interface TranscriptionError extends Error {
  code: 'AUDIO_TOO_LARGE' | 'AUDIO_TOO_SHORT' | 'INVALID_FORMAT' 
      | 'TRANSCRIPTION_FAILED' | 'PARSING_FAILED' | 'RATE_LIMITED' | 'TIMEOUT'
  retryable: boolean
  details?: any
}
```

**Characteristics**:
- Required fields before optional fields
- Use literal types for enums
- Metadata objects for future extensibility
- Extend built-in types when appropriate

### 4. Configuration Pattern
```typescript
const DEFAULT_OPTIONS: Required<TranscriptionOptions> = {
  enableOptimization: true,
  enableCaching: true,
  enableFallback: true,
  maxRetries: 3,
  retryDelay: 1000,
  preferredModel: 'gpt-3.5-turbo',
  confidenceThreshold: 0.7,
  timeout: 30000,
}

export class OptimizedTranscriptionService {
  private options: Required<TranscriptionOptions>
  
  constructor(apiKey: string, options: TranscriptionOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options }
  }
}
```

**Pattern**:
- Define comprehensive defaults
- Use `Required<>` type for internal options
- Merge user options with defaults

## Class and Function Design

### 1. Class Structure Pattern
```typescript
export class TranscriptionCache {
  // Private fields first
  private memoryCache: Map<string, CacheEntry> = new Map()
  private options: Required<CacheOptions>
  private initialized = false

  // Constructor with configuration
  constructor(options: CacheOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options }
  }

  // Public methods
  async initialize(): Promise<void> { }
  async get(audioHash: string, userId: string): Promise<CacheEntry | null> { }
  async set(audioHash: string, transcription: string): Promise<void> { }
  async getStats(): Promise<CacheStats> { }

  // Private methods last
  private async ensureCacheTable(supabase: any): Promise<void> { }
  private dbEntryToCacheEntry(dbEntry: any): CacheEntry { }
  private generateId(): string { }
}
```

**Order**:
1. Private fields
2. Constructor
3. Public methods (logical order)
4. Private methods

### 2. Function Naming Conventions

#### Action Functions
```typescript
// Create/Initialize
createClient()
createAudioOptimizer()
generateAudioHash()

// Get/Retrieve
getUsageTracker()
getTranscriptionCache()
getUserRole()

// Perform Operations
recordTranscription()
optimizeAudio()
transcribeAudio()

// Check/Validate
hasRole()
isAdmin()
validateAudioFile()

// Calculate/Estimate
calculateCost()
estimateDuration()
```

#### Async Function Pattern
```typescript
// Always return Promise with specific type
async function getUserWithProfile(): Promise<UserWithProfile | null>
async function recordTranscription(params: RecordParams): Promise<void>
async function optimizeAudio(blob: Blob): Promise<OptimizationResult>
```

### 3. Method Documentation Pattern
```typescript
/**
 * Record a transcription operation with full metadata
 * @param params Transcription parameters including user, duration, and cost
 * @returns Promise that resolves when metrics are recorded
 */
async recordTranscription(params: {
  userId: string
  audioDuration: number
  fileSize: number
  cached?: boolean
  optimized?: boolean
  compressionRatio?: number
  confidence?: number
  retryCount?: number
  latency?: number
  errorCode?: string
}): Promise<void>
```

**Pattern**:
- Clear, concise description
- Parameter documentation
- Return type documentation
- Include examples for complex functions

## Error Handling Patterns

### 1. Comprehensive Error Classification
```typescript
private normalizeError(error: any): TranscriptionError {
  if (error.code && error.retryable !== undefined) {
    return error as TranscriptionError
  }

  const message = error.message || error.toString()
  
  if (message.includes('timeout') || message.includes('TIMEOUT')) {
    return this.createError('TIMEOUT', 'Request timed out', true)
  }
  
  if (message.includes('rate limit') || message.includes('429')) {
    return this.createError('RATE_LIMITED', 'Rate limit exceeded', true)
  }
  
  return this.createError('TRANSCRIPTION_FAILED', message, true)
}

private createError(code: TranscriptionError['code'], message: string, retryable: boolean): TranscriptionError {
  const error = new Error(message) as TranscriptionError
  error.code = code
  error.retryable = retryable
  return error
}
```

### 2. Retry Logic Pattern
```typescript
async fetchUserProfile(
  userId: string,
  supabaseClient: ReturnType<typeof createClient>,
  retryCount = 0
): Promise<UserProfile | null> {
  const maxRetries = 3
  const backoffDelay = Math.pow(2, retryCount) * 1000 // Exponential backoff

  try {
    // Main operation
    return await performOperation()
  } catch (error) {
    if (retryCount < maxRetries && this.isRetryableError(error)) {
      await new Promise(resolve => setTimeout(resolve, backoffDelay))
      return this.fetchUserProfile(userId, supabaseClient, retryCount + 1)
    }
    throw error
  }
}
```

**Characteristics**:
- Exponential backoff calculation
- Clear retry limit
- Error classification before retry
- Proper error propagation

## React Patterns

### 1. Context Provider Pattern
```typescript
interface AuthContextType {
  user: User | null
  profile: UserProfile | null
  session: Session | null
  isLoading: boolean
  signOut: () => Promise<void>
  refreshAuth: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [profile, setProfile] = useState<UserProfile | null>(null)
  
  // Batched state updates
  React.startTransition(() => {
    setSession(session)
    setUser(session.user)
    setProfile(userProfile)
  })
  
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

### 2. Custom Hook Pattern
```typescript
export function useHasRole(roles: UserRole | UserRole[]): boolean {
  const { user } = useAuth()
  const userRole = useRole()

  // Demo user check first
  if (user?.email && isDemoUser(user.email)) {
    if (process.env.NODE_ENV === 'development') {
      console.log('[useHasRole] Demo user detected - granting full access')
    }
    return true
  }

  // Normal role checking
  if (!userRole) return false
  
  const allowedRoles = Array.isArray(roles) ? roles : [roles]
  return allowedRoles.includes(userRole)
}
```

## Comment and Documentation Style

### 1. Development Logging Pattern
```typescript
if (process.env.NODE_ENV === 'development') {
  console.log('[AuthContext] Fetching profile for user ID:', userId)
  console.log('[useHasRole] Demo user detected - granting access:', {
    email: user.email,
    requiredRoles: roles,
    grantedAccess: true
  })
}
```

**Characteristics**:
- Conditional development logging
- Structured logging with context
- Component/function name prefixes
- Object destructuring for complex data

### 2. Inline Comment Style
```typescript
// Step 1: Generate audio hash for caching
const audioHash = await generateAudioHash(audioBlob)

// Step 2: Check cache first (fastest path)
if (this.options.enableCaching) {
  const cached = await this.cache.get(audioHash, userId)
  if (cached) return this.transformCachedResult(cached)
}

// Step 3: Optimize audio if needed
if (this.options.enableOptimization) {
  optimizationResult = await this.optimizer.optimizeAudio(audioBlob)
}
```

**Pattern**:
- Step-by-step process documentation
- Performance notes in parentheses
- Clear logic flow explanation

### 3. Complex Logic Documentation
```typescript
// Check if it's a network error and we should retry
if (retryCount < maxRetries && (
  error.message?.includes('Failed to fetch') ||
  error.message?.includes('NetworkError') ||
  error.message?.includes('timeout') ||
  error.code === 'PGRST301' // Connection error
)) {
  await new Promise(resolve => setTimeout(resolve, backoffDelay))
  return fetchUserProfile(userId, supabaseClient, retryCount + 1)
}
```

## Performance Optimization Patterns

### 1. Batching Pattern
```typescript
private batchedMetrics: UsageMetrics[] = []
private readonly batchSize = 10
private readonly batchTimeoutMs = 30000

constructor() {
  // Start batch processing timer
  setInterval(() => this.flushBatch(), this.batchTimeoutMs)
}

await this.addToBatch(metrics)

if (this.batchedMetrics.length >= this.batchSize) {
  await this.flushBatch()
}
```

### 2. Singleton Pattern
```typescript
let serviceInstance: OptimizedTranscriptionService | null = null

export function getOptimizedTranscriptionService(
  apiKey?: string, 
  options?: TranscriptionOptions
): OptimizedTranscriptionService {
  if (!serviceInstance) {
    if (!apiKey) {
      throw new Error('OpenAI API key required for first initialization')
    }
    serviceInstance = new OptimizedTranscriptionService(apiKey, options)
  }
  return serviceInstance
}
```

### 3. Memory Management Pattern
```typescript
useEffect(() => {
  let mounted = true
  
  const initializeAuth = async () => {
    if (!mounted) return
    
    // Perform operations...
    
    if (mounted) {
      setAuthState(newState)
    }
  }
  
  return () => {
    mounted = false
    subscription.unsubscribe()
  }
}, []) // Empty dependency array with comment explaining why
```

## Database and API Patterns

### 1. Supabase Query Pattern
```typescript
const { data: profile } = await supabase
  .from('profiles')
  .select('user_id, role, name')
  .eq('user_id', session.user.id)
  .single()
```

**Characteristics**:
- Explicit field selection
- Clear filter conditions
- Consistent destructuring

### 2. Error Handling in Queries
```typescript
const { data: orders, error } = await supabase
  .from('orders')
  .select('items')
  .eq('resident_id', userId)
  .eq('type', orderType)
  .order('created_at', { ascending: false })
  .limit(50)

if (!orders?.length) {
  return []
}

if (error) {
  console.error('Database query failed:', error)
  return []
}
```

## Testing Patterns (Inferred)

### 1. Interface Testing
```typescript
// Test interface compliance
const mockMetrics: UsageMetrics = {
  id: 'test-id',
  userId: 'user123',
  operation: 'transcription',
  // ... all required fields
}

// Test error handling
const mockError: TranscriptionError = {
  name: 'TranscriptionError',
  message: 'Test error',
  code: 'RATE_LIMITED',
  retryable: true
}
```

### 2. Service Testing
```typescript
// Test service composition
const mockCache = createMockCache()
const mockTracker = createMockTracker()
const service = new TranscriptionService(apiKey, {
  cache: mockCache,
  tracker: mockTracker
})
```

This style guide ensures consistency across all implementations and maintains the original developer's high standards for code quality, readability, and maintainability.