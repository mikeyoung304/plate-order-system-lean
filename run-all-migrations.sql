-- Custom types
create type public.app_role as enum ('admin', 'server', 'cook', 'resident');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';


-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;
    claims := event->'claims';
    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;
    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);
    -- Return the modified or original event
    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;
grant all
  on table public.user_roles
to supabase_auth_admin;
revoke all
  on table public.user_roles
  from authenticated, anon, public;
create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)-- Grant necessary permissions
grant usage on schema public to authenticated;
grant select, insert on table public.user_roles to authenticated;

-- Enable RLS
alter table public.user_roles enable row level security;

-- Policies
create policy "Allow users to insert their own role"
  on public.user_roles
  as permissive
  for insert
  to authenticated
  with check (auth.uid() = user_id);

create policy "Allow users to read their own role"
  on public.user_roles
  as permissive
  for select
  to authenticated
  using (auth.uid() = user_id);
-- Function to handle new user creation
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
as $$
declare
  raw_user_meta_data jsonb;
  user_role public.app_role;
begin
  -- Get the raw user metadata
  raw_user_meta_data := new.raw_user_meta_data;
  
  -- Extract the role from metadata
  if raw_user_meta_data ? 'role' then
    user_role := (raw_user_meta_data->>'role')::public.app_role;
    
    -- Insert the role
    insert into public.user_roles (user_id, role)
    values (new.id, user_role);
  end if;
  
  return new;
end;
$$;

-- Grant execute on the function to supabase_auth_admin
grant execute on function public.handle_new_user to supabase_auth_admin;

-- Create the trigger
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();
-- Create tables schema
create table public.tables (
  id uuid default gen_random_uuid() primary key,
  label integer not null,
  type text not null,
  status text not null default 'available'
);

-- Create seats schema
create table public.seats (
  id uuid default gen_random_uuid() primary key,
  table_id uuid references public.tables on delete cascade not null,
  label integer not null,
  status text not null default 'available'
);

-- Enable RLS
alter table public.tables enable row level security;
alter table public.seats enable row level security;

-- Grant access to authenticated users
grant usage on schema public to authenticated;
grant select, update on public.tables to authenticated;
grant select, update on public.seats to authenticated;

-- Admin policies for tables
create policy "Admins can create tables"
  on public.tables
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can delete tables"
  on public.tables
  for delete
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

-- Server/Cook policies for tables
create policy "Servers and cooks can read tables"
  on public.tables
  for select
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role in ('server', 'cook')
    )
  );

create policy "Servers and cooks can update tables"
  on public.tables
  for update
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role in ('server', 'cook')
    )
  );

-- Admin policies for seats
create policy "Admins can create seats"
  on public.seats
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can delete seats"
  on public.seats
  for delete
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

-- Server/Cook policies for seats
create policy "Servers and cooks can read seats"
  on public.seats
  for select
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role in ('server', 'cook')
    )
  );

create policy "Servers and cooks can update seats"
  on public.seats
  for update
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role in ('server', 'cook')
    )
  );

-- Add indexes for better performance
create index tables_label_idx on public.tables(label);
create index seats_table_id_idx on public.seats(table_id);
create index seats_label_idx on public.seats(label);
-- Create orders schema
create table public.orders (
  id uuid default gen_random_uuid() primary key,
  table_id uuid references public.tables on delete cascade not null,
  seat_id uuid references public.seats on delete cascade not null,
  resident_id uuid references auth.users on delete cascade not null,
  server_id uuid references auth.users on delete cascade not null,
  items jsonb not null,
  transcript text,
  status text not null default 'new',
  type text not null,
  created_at timestamptz default now() not null
);

-- Enable RLS
alter table public.orders enable row level security;

-- Grant access to authenticated users
grant usage on schema public to authenticated;
grant select, insert, update on public.orders to authenticated;

-- Admin policies for orders
create policy "Admins can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can delete orders"
  on public.orders
  for delete
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

-- Server policies for orders
create policy "Servers can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

create policy "Servers can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

create policy "Servers can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

-- Cook policies for orders
create policy "Cooks can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

create policy "Cooks can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

create policy "Cooks can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.user_roles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

-- Add indexes for better performance
create index orders_table_id_idx on public.orders(table_id);
create index orders_seat_id_idx on public.orders(seat_id);
create index orders_resident_id_idx on public.orders(resident_id);
create index orders_server_id_idx on public.orders(server_id);
create index orders_created_at_idx on public.orders(created_at);
create index orders_status_idx on public.orders(status);
-- Rename user_roles table to profiles and add name column
alter table public.user_roles rename to profiles;

-- Add name column as nullable first
alter table public.profiles add column name text;

-- Set default value for existing rows
update public.profiles set name = '' where name is null;

-- Now make it not null
alter table public.profiles alter column name set not null;

-- Update all references in functions and policies
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the profiles table
    select role into user_role from public.profiles where user_id = (event->>'user_id')::uuid;
    claims := event->'claims';
    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;
    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);
    -- Return the modified or original event
    return event;
  end;
$$;

-- Update function to handle new user creation
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
as $$
declare
  raw_user_meta_data jsonb;
  user_role public.app_role;
begin
  -- Get the raw user metadata
  raw_user_meta_data := new.raw_user_meta_data;
  
  -- Extract the role from metadata
  if raw_user_meta_data ? 'role' then
    user_role := (raw_user_meta_data->>'role')::public.app_role;
    
    -- Insert into profiles
    insert into public.profiles (user_id, role, name)
    values (new.id, user_role, coalesce(raw_user_meta_data->>'name', ''));
  end if;
  
  return new;
end;
$$;

-- Drop and recreate policies for the profiles table
drop policy if exists "Allow users to insert their own role" on public.profiles;
create policy "Allow users to insert their own profile"
  on public.profiles
  as permissive
  for insert
  to authenticated
  with check (auth.uid() = user_id);

drop policy if exists "Allow users to read their own role" on public.profiles;
create policy "Allow users to read their own profile"
  on public.profiles
  as permissive
  for select
  to authenticated
  using (auth.uid() = user_id);

-- Allow all authenticated users to read resident profiles
create policy "Allow users to read resident profiles"
  on public.profiles
  as permissive
  for select
  to authenticated
  using (role = 'resident');

-- Drop and recreate policies for orders
drop policy if exists "Admins can create orders" on public.orders;
drop policy if exists "Admins can read orders" on public.orders;
drop policy if exists "Admins can update orders" on public.orders;
drop policy if exists "Admins can delete orders" on public.orders;
drop policy if exists "Servers can create orders" on public.orders;
drop policy if exists "Servers can read orders" on public.orders;
drop policy if exists "Servers can update orders" on public.orders;
drop policy if exists "Cooks can create orders" on public.orders;
drop policy if exists "Cooks can read orders" on public.orders;
drop policy if exists "Cooks can update orders" on public.orders;

-- Create admin policies
create policy "Admins can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

create policy "Admins can delete orders"
  on public.orders
  for delete
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'admin'
    )
  );

-- Create server policies
create policy "Servers can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

create policy "Servers can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

create policy "Servers can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'server'
    )
  );

-- Create cook policies
create policy "Cooks can create orders"
  on public.orders
  for insert
  to authenticated
  with check (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

create policy "Cooks can read orders"
  on public.orders
  for select
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

create policy "Cooks can update orders"
  on public.orders
  for update
  to authenticated
  using (
    exists (
      select 1 from public.profiles
      where user_id = auth.uid()
      and role = 'cook'
    )
  );

-- Update table permissions
grant all on table public.profiles to supabase_auth_admin;
revoke all on table public.profiles from authenticated, anon, public;
create policy "Allow auth admin to read profiles" ON public.profiles
as permissive for select
to supabase_auth_admin
using (true);

-- Grant necessary permissions to authenticated users
grant usage on schema public to authenticated;
grant select, insert on table public.profiles to authenticated;
-- Seed initial tables and seats for testing
-- This migration adds some initial table data for the floor plan editor

-- Insert initial tables
INSERT INTO public.tables (id, label, type, status) VALUES 
  (gen_random_uuid(), 1, 'circle', 'available'),
  (gen_random_uuid(), 2, 'circle', 'available'),
  (gen_random_uuid(), 3, 'circle', 'available'),
  (gen_random_uuid(), 4, 'rectangle', 'available'),
  (gen_random_uuid(), 5, 'rectangle', 'available'),
  (gen_random_uuid(), 6, 'rectangle', 'available');

-- Insert seats for each table
-- Table 1: 4 seats
INSERT INTO public.seats (table_id, label, status) 
SELECT id, generate_series(1, 4), 'available' 
FROM public.tables WHERE label = 1;

-- Table 2: 4 seats  
INSERT INTO public.seats (table_id, label, status)
SELECT id, generate_series(1, 4), 'available'
FROM public.tables WHERE label = 2;

-- Table 3: 4 seats
INSERT INTO public.seats (table_id, label, status)
SELECT id, generate_series(1, 4), 'available' 
FROM public.tables WHERE label = 3;

-- Table 4: 6 seats (rectangle)
INSERT INTO public.seats (table_id, label, status)
SELECT id, generate_series(1, 6), 'available'
FROM public.tables WHERE label = 4;

-- Table 5: 6 seats (rectangle)
INSERT INTO public.seats (table_id, label, status)
SELECT id, generate_series(1, 6), 'available'
FROM public.tables WHERE label = 5;

-- Table 6: 8 seats (large rectangle)
INSERT INTO public.seats (table_id, label, status)
SELECT id, generate_series(1, 8), 'available'
FROM public.tables WHERE label = 6;-- Kitchen Display System (KDS) Migration
-- Create comprehensive KDS tables for the revolutionary kitchen display system

-- KDS Stations table for managing different kitchen stations
CREATE TABLE kds_stations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('grill', 'fryer', 'salad', 'expo', 'bar', 'prep', 'dessert')),
  position INTEGER DEFAULT 1,
  color TEXT DEFAULT '#3B82F6', -- Station color for UI
  is_active BOOLEAN DEFAULT true,
  settings JSONB DEFAULT '{}', -- Station-specific settings like auto-bump timing
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- KDS Order Routing table for tracking orders through stations
CREATE TABLE kds_order_routing (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
  station_id UUID REFERENCES kds_stations(id) ON DELETE CASCADE,
  sequence INTEGER DEFAULT 1, -- Order of stations for this order
  routed_at TIMESTAMPTZ DEFAULT NOW(),
  started_at TIMESTAMPTZ, -- When prep started
  completed_at TIMESTAMPTZ, -- When marked ready/bumped
  bumped_by UUID REFERENCES profiles(id),
  bumped_at TIMESTAMPTZ,
  recalled_at TIMESTAMPTZ, -- For order recall functionality
  recall_count INTEGER DEFAULT 0,
  estimated_prep_time INTEGER, -- AI estimated prep time in seconds
  actual_prep_time INTEGER, -- Actual time taken
  notes TEXT, -- Special instructions for this station
  priority INTEGER DEFAULT 0, -- Higher numbers = higher priority
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT unique_order_station UNIQUE(order_id, station_id)
);

-- KDS Performance Metrics table for analytics
CREATE TABLE kds_metrics (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  station_id UUID REFERENCES kds_stations(id) ON DELETE CASCADE,
  order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
  metric_type TEXT NOT NULL CHECK (metric_type IN ('prep_time', 'wait_time', 'bump_time', 'throughput')),
  value_seconds INTEGER, -- Time-based metrics in seconds
  value_count INTEGER, -- Count-based metrics
  recorded_at TIMESTAMPTZ DEFAULT NOW(),
  shift_date DATE DEFAULT CURRENT_DATE,
  hour_of_day INTEGER DEFAULT EXTRACT(hour FROM NOW())
);

-- KDS Configuration table for system settings
CREATE TABLE kds_configuration (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  key TEXT UNIQUE NOT NULL,
  value JSONB NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default KDS stations
INSERT INTO kds_stations (name, type, position, color, settings) VALUES
  ('Grill Station', 'grill', 1, '#EF4444', '{"auto_bump_time": 900, "max_orders": 12}'),
  ('Fryer Station', 'fryer', 2, '#F59E0B', '{"auto_bump_time": 480, "max_orders": 8}'),
  ('Salad Station', 'salad', 3, '#10B981', '{"auto_bump_time": 300, "max_orders": 15}'),
  ('Expo Station', 'expo', 4, '#8B5CF6', '{"auto_bump_time": 120, "max_orders": 20}'),
  ('Bar Station', 'bar', 5, '#06B6D4', '{"auto_bump_time": 180, "max_orders": 10}');

-- Insert default KDS configuration
INSERT INTO kds_configuration (key, value, description) VALUES
  ('timing_thresholds', '{"green": 300, "yellow": 600, "red": 900}', 'Color coding thresholds in seconds'),
  ('voice_commands_enabled', 'true', 'Enable voice command functionality'),
  ('auto_refresh_interval', '5000', 'Auto refresh interval in milliseconds'),
  ('max_orders_per_screen', '24', 'Maximum orders to display per screen'),
  ('sound_alerts_enabled', 'true', 'Enable sound alerts for new orders'),
  ('prediction_model_enabled', 'true', 'Enable AI prep time predictions');

-- Create indexes for performance
CREATE INDEX idx_kds_order_routing_order_station ON kds_order_routing(order_id, station_id);
CREATE INDEX idx_kds_order_routing_station_active ON kds_order_routing(station_id) WHERE completed_at IS NULL;
CREATE INDEX idx_kds_order_routing_routed_at ON kds_order_routing(routed_at);
CREATE INDEX idx_kds_metrics_station_date ON kds_metrics(station_id, shift_date);
CREATE INDEX idx_kds_metrics_recorded_at ON kds_metrics(recorded_at);

-- Enable Row Level Security
ALTER TABLE kds_stations ENABLE ROW LEVEL SECURITY;
ALTER TABLE kds_order_routing ENABLE ROW LEVEL SECURITY;
ALTER TABLE kds_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE kds_configuration ENABLE ROW LEVEL SECURITY;

-- RLS Policies for KDS stations
CREATE POLICY "Users can view all KDS stations" ON kds_stations
  FOR SELECT TO authenticated USING (true);

CREATE POLICY "Admins can manage KDS stations" ON kds_stations
  FOR ALL TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role = 'admin'
    )
  );

-- RLS Policies for order routing
CREATE POLICY "Kitchen staff can view order routing" ON kds_order_routing
  FOR SELECT TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role IN ('cook', 'admin')
    )
  );

CREATE POLICY "Kitchen staff can update order routing" ON kds_order_routing
  FOR UPDATE TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role IN ('cook', 'admin')
    )
  );

CREATE POLICY "Kitchen staff can insert order routing" ON kds_order_routing
  FOR INSERT TO authenticated WITH CHECK (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role IN ('cook', 'admin')
    )
  );

-- RLS Policies for metrics
CREATE POLICY "Kitchen staff can view metrics" ON kds_metrics
  FOR SELECT TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role IN ('cook', 'admin')
    )
  );

CREATE POLICY "System can insert metrics" ON kds_metrics
  FOR INSERT TO authenticated WITH CHECK (true);

-- RLS Policies for configuration
CREATE POLICY "Kitchen staff can view KDS configuration" ON kds_configuration
  FOR SELECT TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role IN ('cook', 'admin')
    )
  );

CREATE POLICY "Admins can manage KDS configuration" ON kds_configuration
  FOR ALL TO authenticated USING (
    auth.uid() IN (
      SELECT user_id FROM profiles WHERE role = 'admin'
    )
  );

-- Create function to automatically route new orders to appropriate stations
CREATE OR REPLACE FUNCTION auto_route_order_to_stations()
RETURNS trigger AS $$
BEGIN
  -- Route food orders to grill, then expo
  IF NEW.type = 'food' THEN
    INSERT INTO kds_order_routing (order_id, station_id, sequence)
    SELECT NEW.id, id, 1 FROM kds_stations WHERE type = 'grill' AND is_active = true;
    
    INSERT INTO kds_order_routing (order_id, station_id, sequence)
    SELECT NEW.id, id, 2 FROM kds_stations WHERE type = 'expo' AND is_active = true;
  END IF;
  
  -- Route beverage orders to bar
  IF NEW.type = 'beverage' THEN
    INSERT INTO kds_order_routing (order_id, station_id, sequence)
    SELECT NEW.id, id, 1 FROM kds_stations WHERE type = 'bar' AND is_active = true;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for auto-routing
CREATE TRIGGER trigger_auto_route_orders
  AFTER INSERT ON orders
  FOR EACH ROW
  EXECUTE FUNCTION auto_route_order_to_stations();

-- Create function to calculate prep time metrics
CREATE OR REPLACE FUNCTION calculate_prep_time_metrics()
RETURNS trigger AS $$
BEGIN
  -- Calculate actual prep time when order is completed
  IF OLD.completed_at IS NULL AND NEW.completed_at IS NOT NULL THEN
    -- Insert prep time metric
    INSERT INTO kds_metrics (station_id, order_id, metric_type, value_seconds)
    VALUES (
      NEW.station_id,
      NEW.order_id,
      'prep_time',
      EXTRACT(EPOCH FROM (NEW.completed_at - NEW.routed_at))::INTEGER
    );
    
    -- Update the actual prep time in routing table
    NEW.actual_prep_time := EXTRACT(EPOCH FROM (NEW.completed_at - NEW.routed_at))::INTEGER;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for metrics calculation
CREATE TRIGGER trigger_calculate_prep_metrics
  BEFORE UPDATE ON kds_order_routing
  FOR EACH ROW
  EXECUTE FUNCTION calculate_prep_time_metrics();

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add updated_at triggers
CREATE TRIGGER trigger_kds_stations_updated_at
  BEFORE UPDATE ON kds_stations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_kds_order_routing_updated_at
  BEFORE UPDATE ON kds_order_routing
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_kds_configuration_updated_at
  BEFORE UPDATE ON kds_configuration
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();