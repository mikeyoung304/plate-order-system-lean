# Security Patterns: Defense-in-Depth Implementation

## üõ°Ô∏è Overview

Luis Galeana's security architecture implements a comprehensive "Security-by-Design" philosophy where security considerations are built into every layer of the application, not added as an afterthought. This approach resulted in **zero security incidents** during the analyzed period and provides enterprise-grade protection through multiple defensive layers.

## üéØ Security Philosophy

### **Security-by-Design Principles**

1. **Input Validation at Every Boundary**: Never trust any input, even from trusted sources
2. **Defense in Depth**: Multiple security layers prevent single points of failure
3. **Fail Secure**: When errors occur, default to denying access
4. **Principle of Least Privilege**: Grant minimum necessary permissions
5. **Comprehensive Logging**: All security events are logged for audit and analysis

## üîí Core Security Patterns

### **1. Input Sanitization Pattern**

Every function that accepts external input implements comprehensive sanitization:

```typescript
/**
 * File generated by Modular Assembly - Security Pattern
 * IMPORTANT!!! Ask the user before editing this file.
 */

import { Security } from '@/lib/security'

export async function processUserInput(input: string, limit?: number): Promise<Result> {
  // Step 1: Basic sanitization
  const sanitizedInput = Security.sanitize.sanitizeInput(input)
  if (!sanitizedInput || sanitizedInput.length === 0) {
    throw new Error('Invalid input provided')
  }

  // Step 2: Length validation
  if (sanitizedInput.length > 1000) {
    throw new Error('Input exceeds maximum length')
  }

  // Step 3: Content validation (prevent injection)
  if (Security.validate.containsSqlInjection(sanitizedInput)) {
    throw new Error('Invalid characters detected')
  }

  // Step 4: Numeric parameter clamping
  const safeLimit = Math.max(1, Math.min(100, Math.floor(limit || 10)))

  // Step 5: Process with monitoring
  return await measureApiCall('process_user_input', async () => {
    const result = await processData(sanitizedInput, safeLimit)
    return Security.sanitize.sanitizeOutput(result)
  })
}
```

### **2. Identifier Validation Pattern**

All database identifiers undergo strict validation:

```typescript
export async function fetchOrderById(orderId: string): Promise<Order | null> {
  // Security: Validate and sanitize identifier
  const sanitizedOrderId = Security.sanitize.sanitizeIdentifier(orderId)
  if (!sanitizedOrderId) {
    throw new Error('Invalid order ID provided')
  }

  // UUID validation for extra security
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  if (!uuidRegex.test(sanitizedOrderId)) {
    throw new Error('Invalid order ID format')
  }

  // Additional business logic validation
  if (await Security.validate.isBlacklistedId(sanitizedOrderId)) {
    throw new Error('Access denied for this resource')
  }

  return await measureApiCall('fetch_order_by_id', async () => {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('orders')
      .select('*')
      .eq('id', sanitizedOrderId)
      .single()

    if (error) {
      Security.audit.logDatabaseError('fetch_order', error, { orderId: sanitizedOrderId })
      throw new Error('Order not found')
    }

    return Security.sanitize.sanitizeOutput(data)
  })
}
```

### **3. Value Clamping Pattern**

Prevent resource exhaustion through intelligent value clamping:

```typescript
export async function fetchRecentOrders(limit = 5, offset = 0): Promise<Order[]> {
  // Security: Clamp values to prevent resource exhaustion
  const safeLimit = Math.max(1, Math.min(50, Math.floor(limit)))
  const safeOffset = Math.max(0, Math.min(10000, Math.floor(offset)))

  // Additional business rule validation
  if (safeLimit * safeOffset > 100000) {
    throw new Error('Query scope too large')
  }

  return await measureApiCall('fetch_recent_orders', async () => {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('orders')
      .select('*')
      .order('created_at', { ascending: false })
      .range(safeOffset, safeOffset + safeLimit - 1)

    if (error) {
      Security.audit.logDatabaseError('fetch_recent_orders', error, { 
        limit: safeLimit, 
        offset: safeOffset 
      })
      throw error
    }

    return data.map(order => Security.sanitize.sanitizeOutput(order))
  })
}
```

## üîê Authentication Security

### **Session Management Pattern**

Secure session handling with comprehensive validation:

```typescript
/**
 * Enhanced Session Management with Security Validation
 */
export async function validateSession(request: NextRequest): Promise<SessionValidationResult> {
  try {
    // Step 1: Extract session token
    const sessionToken = await extractSessionToken(request)
    if (!sessionToken) {
      return { valid: false, reason: 'No session token' }
    }

    // Step 2: Validate token format
    if (!Security.validate.isValidSessionToken(sessionToken)) {
      Security.audit.logSecurityEvent('invalid_session_format', {
        ip: request.ip,
        userAgent: request.headers.get('user-agent')
      })
      return { valid: false, reason: 'Invalid token format' }
    }

    // Step 3: Check session in database
    const session = await validateSessionInDatabase(sessionToken)
    if (!session) {
      return { valid: false, reason: 'Session not found' }
    }

    // Step 4: Check session expiry
    if (session.expiresAt < new Date()) {
      await invalidateSession(sessionToken)
      return { valid: false, reason: 'Session expired' }
    }

    // Step 5: Validate IP address (optional security layer)
    if (Security.config.enableIpValidation) {
      if (!await Security.validate.isValidIpForSession(request.ip, session)) {
        Security.audit.logSecurityEvent('suspicious_ip_access', {
          sessionId: session.id,
          expectedIp: session.lastIp,
          actualIp: request.ip
        })
        // Don't fail immediately - log for investigation
      }
    }

    // Step 6: Update session activity
    await updateSessionActivity(session.id, request.ip)

    return { 
      valid: true, 
      session: Security.sanitize.sanitizeSession(session) 
    }

  } catch (error) {
    Security.audit.logSecurityError('session_validation_error', error)
    return { valid: false, reason: 'Validation error' }
  }
}
```

### **Demo User Security Pattern**

Sophisticated demo user handling that maintains security:

```typescript
/**
 * Demo User Security Implementation
 * Provides bypass capabilities while maintaining audit trails
 */
export async function checkUserPermissions(
  userId: string, 
  requiredPermission: Permission,
  context: SecurityContext
): Promise<PermissionResult> {
  
  // Security logging for all permission checks
  Security.audit.logPermissionCheck({
    userId,
    permission: requiredPermission,
    context: context.action,
    timestamp: Date.now()
  })

  // Demo user bypass with comprehensive logging
  if (await isDemoUser(userId)) {
    Security.audit.logDemoAccess({
      userId,
      permission: requiredPermission,
      context: context.action,
      bypassReason: 'demo_user',
      environment: process.env.NODE_ENV
    })

    // Only allow demo bypass in non-production environments
    if (process.env.NODE_ENV === 'production' && !Security.config.allowProductionDemo) {
      Security.audit.logSecurityEvent('demo_bypass_blocked_production', { userId })
      return { allowed: false, reason: 'Demo access not allowed in production' }
    }

    return { 
      allowed: true, 
      reason: 'demo_user_bypass',
      metadata: { isDemoUser: true }
    }
  }

  // Standard permission checking for regular users
  const userPermissions = await getUserPermissions(userId)
  const hasPermission = userPermissions.includes(requiredPermission)

  if (!hasPermission) {
    Security.audit.logPermissionDenied({
      userId,
      permission: requiredPermission,
      userPermissions,
      context: context.action
    })
  }

  return {
    allowed: hasPermission,
    reason: hasPermission ? 'permission_granted' : 'insufficient_permissions',
    metadata: { userPermissions }
  }
}

async function isDemoUser(userId: string): Promise<boolean> {
  // Check against demo user list with caching
  const demoUsers = await Security.cache.getDemoUsers()
  return demoUsers.includes(userId) || 
         await Security.database.isDemoUser(userId)
}
```

## üîç Input Validation Implementation

### **Security Sanitization Library**

```typescript
/**
 * Comprehensive Security Sanitization Library
 * Used throughout the application for input/output validation
 */
export class SecuritySanitizer {
  
  /**
   * Sanitize user input to prevent XSS and injection attacks
   */
  static sanitizeInput(input: string): string {
    if (typeof input !== 'string') {
      throw new Error('Input must be a string')
    }

    // Step 1: Trim whitespace
    let sanitized = input.trim()

    // Step 2: Remove null bytes
    sanitized = sanitized.replace(/\0/g, '')

    // Step 3: Escape HTML entities
    sanitized = sanitized
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')

    // Step 4: Remove suspicious patterns
    const suspiciousPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /data:\w+\/\w+;base64/gi
    ]

    for (const pattern of suspiciousPatterns) {
      sanitized = sanitized.replace(pattern, '')
    }

    return sanitized
  }

  /**
   * Sanitize database identifiers
   */
  static sanitizeIdentifier(id: string): string | null {
    if (typeof id !== 'string') {
      return null
    }

    // Remove whitespace
    const trimmed = id.trim()

    // Check basic format
    if (trimmed.length === 0 || trimmed.length > 100) {
      return null
    }

    // Allow only alphanumeric, hyphens, and underscores
    if (!/^[a-zA-Z0-9_-]+$/.test(trimmed)) {
      return null
    }

    return trimmed
  }

  /**
   * Sanitize output to prevent data leakage
   */
  static sanitizeOutput<T>(data: T): T {
    if (data === null || data === undefined) {
      return data
    }

    if (typeof data === 'string') {
      return this.sanitizeInput(data) as T
    }

    if (Array.isArray(data)) {
      return data.map(item => this.sanitizeOutput(item)) as T
    }

    if (typeof data === 'object') {
      const sanitized = {} as T
      for (const [key, value] of Object.entries(data)) {
        // Skip sensitive fields
        if (this.isSensitiveField(key)) {
          continue
        }
        sanitized[key as keyof T] = this.sanitizeOutput(value)
      }
      return sanitized
    }

    return data
  }

  /**
   * Check if field contains sensitive information
   */
  private static isSensitiveField(fieldName: string): boolean {
    const sensitiveFields = [
      'password',
      'token',
      'secret',
      'key',
      'private',
      'credit_card',
      'ssn',
      'internal_notes'
    ]

    return sensitiveFields.some(sensitive => 
      fieldName.toLowerCase().includes(sensitive)
    )
  }
}
```

### **Advanced Validation Patterns**

```typescript
/**
 * Advanced Input Validation for Complex Data Types
 */
export class SecurityValidator {

  /**
   * Validate order data with business rules
   */
  static validateOrderData(orderData: any): ValidationResult {
    const errors: string[] = []

    // Required fields validation
    if (!orderData.table_id) {
      errors.push('Table ID is required')
    } else if (!this.isValidTableId(orderData.table_id)) {
      errors.push('Invalid table ID format')
    }

    if (!orderData.items || !Array.isArray(orderData.items)) {
      errors.push('Items array is required')
    } else {
      // Validate each item
      for (let i = 0; i < orderData.items.length; i++) {
        const itemErrors = this.validateOrderItem(orderData.items[i], i)
        errors.push(...itemErrors)
      }

      // Business rule: max 20 items per order
      if (orderData.items.length > 20) {
        errors.push('Maximum 20 items allowed per order')
      }
    }

    // Validate monetary amounts
    if (orderData.total_amount !== undefined) {
      if (!this.isValidMonetaryAmount(orderData.total_amount)) {
        errors.push('Invalid total amount')
      }
    }

    return {
      valid: errors.length === 0,
      errors
    }
  }

  /**
   * Validate individual order item
   */
  private static validateOrderItem(item: any, index: number): string[] {
    const errors: string[] = []

    if (!item.name || typeof item.name !== 'string') {
      errors.push(`Item ${index}: Name is required`)
    } else if (item.name.length > 100) {
      errors.push(`Item ${index}: Name too long`)
    }

    if (item.quantity !== undefined) {
      if (!Number.isInteger(item.quantity) || item.quantity < 1 || item.quantity > 99) {
        errors.push(`Item ${index}: Quantity must be between 1 and 99`)
      }
    }

    if (item.price !== undefined) {
      if (!this.isValidMonetaryAmount(item.price)) {
        errors.push(`Item ${index}: Invalid price format`)
      }
    }

    return errors
  }

  /**
   * Validate monetary amounts
   */
  private static isValidMonetaryAmount(amount: any): boolean {
    if (typeof amount !== 'number') {
      return false
    }

    // Check for reasonable range (0 to $10,000)
    if (amount < 0 || amount > 10000) {
      return false
    }

    // Check for valid decimal places (max 2)
    const decimalPlaces = (amount.toString().split('.')[1] || '').length
    if (decimalPlaces > 2) {
      return false
    }

    return true
  }

  /**
   * Validate table ID format
   */
  private static isValidTableId(tableId: string): boolean {
    // Must be UUID format or specific table format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
    const tableFormatRegex = /^table-\d{1,3}$/i
    
    return uuidRegex.test(tableId) || tableFormatRegex.test(tableId)
  }
}
```

## üîí Database Security Patterns

### **Row-Level Security Integration**

```typescript
/**
 * Database Operations with RLS Integration
 * Ensures data access follows security policies
 */
export async function fetchUserOrders(userId: string): Promise<Order[]> {
  // Security: Validate user ID
  const sanitizedUserId = Security.sanitize.sanitizeIdentifier(userId)
  if (!sanitizedUserId) {
    throw new Error('Invalid user ID')
  }

  // Security: Verify user session and permissions
  const hasPermission = await Security.permissions.canAccessOrders(sanitizedUserId)
  if (!hasPermission) {
    Security.audit.logUnauthorizedAccess('fetch_user_orders', { userId: sanitizedUserId })
    throw new Error('Unauthorized access to orders')
  }

  return await measureApiCall('fetch_user_orders', async () => {
    const supabase = createClient()
    
    // RLS policies will automatically filter results based on user context
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        tables!inner(label),
        seats!inner(label)
      `)
      .eq('user_id', sanitizedUserId)
      .order('created_at', { ascending: false })

    if (error) {
      Security.audit.logDatabaseError('fetch_user_orders', error, { userId: sanitizedUserId })
      throw new Error('Failed to fetch orders')
    }

    // Additional security: sanitize all output
    return data.map(order => Security.sanitize.sanitizeOutput(order))
  })
}
```

### **SQL Injection Prevention**

```typescript
/**
 * Secure Query Builder with Parameterization
 * Prevents SQL injection through proper parameterization
 */
export class SecureQueryBuilder {
  
  static async dynamicQuery(
    tableName: string, 
    filters: Record<string, any>,
    options: QueryOptions = {}
  ): Promise<any[]> {
    
    // Security: Validate table name against allowlist
    if (!this.isValidTableName(tableName)) {
      throw new Error('Invalid table name')
    }

    // Security: Sanitize and validate all filter values
    const sanitizedFilters = this.sanitizeFilters(filters)
    
    // Security: Validate query options
    const safeOptions = this.sanitizeQueryOptions(options)

    const supabase = createClient()
    let query = supabase.from(tableName).select(safeOptions.select || '*')

    // Apply filters using parameterized queries (Supabase handles this)
    for (const [column, value] of Object.entries(sanitizedFilters)) {
      if (!this.isValidColumnName(column)) {
        throw new Error(`Invalid column name: ${column}`)
      }
      query = query.eq(column, value)
    }

    // Apply safe ordering
    if (safeOptions.orderBy) {
      query = query.order(safeOptions.orderBy, { 
        ascending: safeOptions.ascending ?? true 
      })
    }

    // Apply safe limiting
    if (safeOptions.limit) {
      query = query.limit(safeOptions.limit)
    }

    const { data, error } = await query

    if (error) {
      Security.audit.logDatabaseError('dynamic_query', error, { 
        table: tableName, 
        filters: sanitizedFilters 
      })
      throw new Error('Query execution failed')
    }

    return data || []
  }

  private static isValidTableName(tableName: string): boolean {
    const allowedTables = [
      'orders', 'tables', 'seats', 'users', 'profiles', 
      'order_items', 'restaurants', 'kds_stations'
    ]
    return allowedTables.includes(tableName)
  }

  private static isValidColumnName(columnName: string): boolean {
    // Allow only alphanumeric and underscores
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(columnName)
  }

  private static sanitizeFilters(filters: Record<string, any>): Record<string, any> {
    const sanitized: Record<string, any> = {}
    
    for (const [key, value] of Object.entries(filters)) {
      if (typeof value === 'string') {
        sanitized[key] = Security.sanitize.sanitizeInput(value)
      } else if (typeof value === 'number') {
        sanitized[key] = Math.max(-999999, Math.min(999999, value))
      } else if (typeof value === 'boolean') {
        sanitized[key] = value
      } else {
        // Skip complex types for security
        continue
      }
    }
    
    return sanitized
  }
}
```

## üìä Security Monitoring and Auditing

### **Comprehensive Audit Logging**

```typescript
/**
 * Security Audit System
 * Comprehensive logging for security analysis and compliance
 */
export class SecurityAudit {
  
  /**
   * Log security events for monitoring
   */
  static async logSecurityEvent(
    eventType: string, 
    details: Record<string, any>,
    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'
  ): Promise<void> {
    const event = {
      id: generateId(),
      type: eventType,
      severity,
      details: Security.sanitize.sanitizeOutput(details),
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV,
      source: 'security_audit'
    }

    // Log to multiple destinations for redundancy
    await Promise.all([
      this.logToDatabase(event),
      this.logToFile(event),
      severity === 'critical' ? this.alertSecurityTeam(event) : Promise.resolve()
    ])
  }

  /**
   * Log authentication events
   */
  static async logAuthEvent(
    userId: string,
    action: string,
    success: boolean,
    metadata: Record<string, any> = {}
  ): Promise<void> {
    await this.logSecurityEvent('auth_event', {
      userId: Security.sanitize.sanitizeIdentifier(userId),
      action,
      success,
      ip: metadata.ip,
      userAgent: metadata.userAgent,
      sessionId: metadata.sessionId
    }, success ? 'low' : 'medium')
  }

  /**
   * Log data access events
   */
  static async logDataAccess(
    userId: string,
    resource: string,
    action: string,
    authorized: boolean,
    metadata: Record<string, any> = {}
  ): Promise<void> {
    await this.logSecurityEvent('data_access', {
      userId: Security.sanitize.sanitizeIdentifier(userId),
      resource,
      action,
      authorized,
      sensitive: metadata.sensitive || false,
      recordCount: metadata.recordCount
    }, authorized ? 'low' : 'high')
  }

  /**
   * Log suspicious activity
   */
  static async logSuspiciousActivity(
    description: string,
    details: Record<string, any>,
    autoBlock: boolean = false
  ): Promise<void> {
    await this.logSecurityEvent('suspicious_activity', {
      description,
      details: Security.sanitize.sanitizeOutput(details),
      autoBlocked: autoBlock
    }, 'high')

    if (autoBlock) {
      await this.triggerAutoBlock(details)
    }
  }

  private static async triggerAutoBlock(details: Record<string, any>): Promise<void> {
    // Implement automatic blocking logic for suspicious IPs or users
    if (details.ip) {
      await Security.firewall.blockIp(details.ip, 'suspicious_activity', 3600) // 1 hour
    }
    
    if (details.userId) {
      await Security.session.invalidateUserSessions(details.userId)
    }
  }
}
```

## üéØ Security Metrics and KPIs

### **Security Dashboard Metrics**

```typescript
/**
 * Security Metrics Collection
 * Real-time security monitoring and alerting
 */
export class SecurityMetrics {
  
  static async getSecurityDashboard(timeRange: TimeRange): Promise<SecurityDashboard> {
    const [
      authMetrics,
      accessMetrics,
      threatMetrics,
      auditMetrics
    ] = await Promise.all([
      this.getAuthenticationMetrics(timeRange),
      this.getAccessControlMetrics(timeRange),
      this.getThreatDetectionMetrics(timeRange),
      this.getAuditMetrics(timeRange)
    ])

    return {
      authentication: authMetrics,
      accessControl: accessMetrics,
      threatDetection: threatMetrics,
      audit: auditMetrics,
      overallScore: this.calculateSecurityScore(authMetrics, accessMetrics, threatMetrics),
      generatedAt: new Date().toISOString()
    }
  }

  private static async getAuthenticationMetrics(timeRange: TimeRange) {
    return {
      totalLogins: await this.countEvents('auth_event', { action: 'login' }, timeRange),
      failedLogins: await this.countEvents('auth_event', { action: 'login', success: false }, timeRange),
      successRate: await this.calculateSuccessRate('auth_event', timeRange),
      uniqueUsers: await this.countUniqueUsers(timeRange),
      suspiciousLogins: await this.countEvents('suspicious_activity', { type: 'auth' }, timeRange)
    }
  }

  private static calculateSecurityScore(
    auth: any, 
    access: any, 
    threat: any
  ): number {
    // Calculate overall security score based on various metrics
    const authScore = Math.max(0, 100 - (auth.failedLogins / auth.totalLogins * 100))
    const accessScore = Math.max(0, 100 - (access.unauthorizedAttempts / access.totalAttempts * 100))
    const threatScore = Math.max(0, 100 - threat.detectedThreats * 10)

    return Math.round((authScore + accessScore + threatScore) / 3)
  }
}
```

## üöÄ Implementation Guidelines

### **Security Implementation Checklist**

#### **Input Validation (Required)**
- [ ] Implement `Security.sanitize.sanitizeInput()` for all user inputs
- [ ] Add `Security.sanitize.sanitizeIdentifier()` for all database IDs
- [ ] Implement value clamping for numeric inputs
- [ ] Add business rule validation for complex data types

#### **Authentication Security (Required)**
- [ ] Implement comprehensive session validation
- [ ] Add demo user bypass with audit logging
- [ ] Configure IP validation for sensitive operations
- [ ] Implement automatic session timeout

#### **Database Security (Required)**
- [ ] Configure Row-Level Security (RLS) policies
- [ ] Implement parameterized queries only
- [ ] Add comprehensive audit logging for data access
- [ ] Validate table and column names against allowlists

#### **Monitoring and Auditing (Recommended)**
- [ ] Implement security event logging
- [ ] Configure real-time threat detection
- [ ] Set up security metrics dashboard
- [ ] Configure automated alerting for critical events

### **Security Testing Checklist**

- [ ] SQL injection testing on all inputs
- [ ] XSS testing on all user-generated content
- [ ] Authentication bypass testing
- [ ] Authorization testing for all user roles
- [ ] Session management testing
- [ ] Input validation boundary testing
- [ ] Audit log integrity testing

---

**Next**: Review [`06-database-abstraction-layer.md`](./06-database-abstraction-layer.md) for performance monitoring and optimization patterns.