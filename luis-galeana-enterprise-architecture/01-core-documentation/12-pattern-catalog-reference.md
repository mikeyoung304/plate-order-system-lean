# Pattern Catalog Reference

## üéØ Quick Reference Guide

This comprehensive reference catalog provides instant access to all Luis Galeana's architectural patterns discovered through forensic analysis. Use this as a daily development reference for implementing Modular Assembly patterns.

## üìã Pattern Index

| Pattern | Tier | Purpose | Complexity | Implementation Time |
|---------|------|---------|------------|-------------------|
| [File Generation Header](#file-generation-header) | All | Ownership & Modification Control | Low | 5 min |
| [Input Sanitization](#input-sanitization) | All | Security & Validation | Medium | 15 min |
| [Value Clamping](#value-clamping) | All | Resource Protection | Low | 10 min |
| [Lazy Initialization](#lazy-initialization) | Foundation | Resource Management | Medium | 20 min |
| [Connection Pooling](#connection-pooling) | Production | Performance | High | 60 min |
| [Enterprise Monitoring](#enterprise-monitoring) | Enterprise | Observability | High | 120 min |
| [Demo User Bypass](#demo-user-bypass) | All | Development Support | Medium | 30 min |
| [Three-Tier Architecture](#three-tier-architecture) | All | Scalability Strategy | High | Variable |

## üèóÔ∏è Core Patterns

### **File Generation Header**
**Purpose**: Establish clear ownership and modification protocols
**Tier**: All tiers
**Implementation**: 5 minutes

```typescript
/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

// Your implementation here
```

**When to Use**: Every file in the modassembly structure
**Benefits**: Clear ownership, modification control, quality assurance

---

### **Input Sanitization**
**Purpose**: Prevent injection attacks and ensure data integrity
**Tier**: All tiers
**Implementation**: 15 minutes

```typescript
export async function processUserInput(input: string): Promise<Result> {
  // Step 1: Basic sanitization
  const sanitizedInput = Security.sanitize.sanitizeInput(input)
  if (!sanitizedInput || sanitizedInput.length === 0) {
    throw new Error('Invalid input provided')
  }

  // Step 2: Length validation
  if (sanitizedInput.length > 1000) {
    throw new Error('Input exceeds maximum length')
  }

  // Step 3: Process safely
  return await processData(sanitizedInput)
}
```

**When to Use**: Every function accepting external input
**Benefits**: XSS prevention, SQL injection prevention, data integrity

---

### **Value Clamping**
**Purpose**: Prevent resource exhaustion and ensure reasonable bounds
**Tier**: All tiers
**Implementation**: 10 minutes

```typescript
export async function fetchItems(limit = 10, offset = 0): Promise<Item[]> {
  // Clamp values to reasonable ranges
  const safeLimit = Math.max(1, Math.min(100, Math.floor(limit)))
  const safeOffset = Math.max(0, Math.min(10000, Math.floor(offset)))

  // Use clamped values
  return await database.fetchItems(safeLimit, safeOffset)
}
```

**When to Use**: All numeric parameters, especially limits and offsets
**Benefits**: Resource protection, DoS prevention, predictable behavior

---

### **Lazy Initialization**
**Purpose**: Efficient resource management for external services
**Tier**: Foundation+
**Implementation**: 20 minutes

```typescript
let openaiClient: OpenAI | null = null

function getOpenAIClient(): OpenAI {
  if (!openaiClient) {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY environment variable is not set')
    }
    openaiClient = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    })
  }
  return openaiClient
}
```

**When to Use**: External service clients, expensive object creation
**Benefits**: Performance optimization, resource efficiency, error handling

---

### **Connection Pooling**
**Purpose**: Optimize database connections for high concurrency
**Tier**: Production+
**Implementation**: 60 minutes

```typescript
export class OptimizedSupabaseClient {
  private static instance: OptimizedSupabaseClient | null = null
  private connectionPool: SupabaseClient[] = []

  constructor() {
    this.initializePool()
  }

  private initializePool(): void {
    for (let i = 0; i < 10; i++) {
      const client = createBrowserClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      )
      this.connectionPool.push(client)
    }
  }

  public getAvailableConnection(): SupabaseClient<Database> {
    return this.connectionPool[Math.floor(Math.random() * this.connectionPool.length)]
  }
}
```

**When to Use**: > 100 concurrent users, production deployments
**Benefits**: Improved performance, reduced latency, better resource utilization

---

### **Enterprise Monitoring**
**Purpose**: Comprehensive tracking for enterprise deployments
**Tier**: Enterprise
**Implementation**: 120 minutes

```typescript
export class EnterpriseMonitoring {
  async executeWithMonitoring<T>(
    operation: string,
    func: () => Promise<T>,
    metadata: Record<string, any> = {}
  ): Promise<T> {
    const startTime = Date.now()
    const operationId = generateOperationId()

    try {
      // Pre-operation hooks
      await this.recordOperationStart(operationId, operation, metadata)

      // Execute operation
      const result = await func()

      // Post-operation success hooks
      await this.recordOperationSuccess(operationId, Date.now() - startTime)

      return result
    } catch (error) {
      // Post-operation failure hooks
      await this.recordOperationFailure(operationId, Date.now() - startTime, error)
      throw error
    }
  }
}
```

**When to Use**: > 1000 concurrent users, compliance requirements
**Benefits**: Full observability, compliance logging, performance insights

---

### **Demo User Bypass**
**Purpose**: Enable development and sales demonstrations without security friction
**Tier**: All tiers
**Implementation**: 30 minutes

```typescript
export async function checkPermissions(userId: string, permission: Permission): Promise<boolean> {
  // Demo user bypass with comprehensive logging
  if (await isDemoUser(userId)) {
    await Security.audit.logDemoAccess({
      userId,
      permission,
      environment: process.env.NODE_ENV,
      timestamp: Date.now()
    })

    // Only allow in non-production or with explicit flag
    if (process.env.NODE_ENV === 'production' && !Security.config.allowProductionDemo) {
      return false
    }

    return true
  }

  // Standard permission checking
  return await hasUserPermission(userId, permission)
}
```

**When to Use**: All permission checks, demo environments, sales presentations
**Benefits**: Development velocity, sales enablement, audit compliance

## üîí Security Patterns

### **ID Validation Pattern**

```typescript
function validateAndSanitizeId(id: string): string | null {
  const sanitized = Security.sanitize.sanitizeIdentifier(id)
  if (!sanitized) return null

  // UUID validation
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  if (!uuidRegex.test(sanitized)) return null

  return sanitized
}
```

### **Output Sanitization Pattern**

```typescript
function sanitizeOutput<T>(data: T): T {
  if (typeof data === 'object' && data !== null) {
    const sanitized = {} as T
    for (const [key, value] of Object.entries(data)) {
      if (!isSensitiveField(key)) {
        sanitized[key as keyof T] = sanitizeOutput(value)
      }
    }
    return sanitized
  }
  return data
}
```

### **Audit Logging Pattern**

```typescript
async function logSecurityEvent(event: string, details: Record<string, any>) {
  await Security.audit.log({
    event,
    details: Security.sanitize.sanitizeOutput(details),
    timestamp: new Date().toISOString(),
    severity: determineSeverity(event)
  })
}
```

## üìä Performance Patterns

### **Performance Monitoring Pattern**

```typescript
async function measureApiCall<T>(
  operationName: string,
  operation: () => Promise<T>
): Promise<T> {
  const startTime = Date.now()
  
  try {
    const result = await operation()
    
    Performance.recordSuccess({
      operation: operationName,
      duration: Date.now() - startTime,
      timestamp: startTime
    })
    
    return result
  } catch (error) {
    Performance.recordFailure({
      operation: operationName,
      duration: Date.now() - startTime,
      error: error.message,
      timestamp: startTime
    })
    throw error
  }
}
```

### **Retry Logic Pattern**

```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxAttempts = 3
): Promise<T> {
  let lastError: Error

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error as Error
      
      if (attempt < maxAttempts) {
        const delay = Math.pow(2, attempt) * 1000 // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }
  }

  throw new Error(`Operation failed after ${maxAttempts} attempts: ${lastError.message}`)
}
```

### **Caching Pattern**

```typescript
class IntelligentCache {
  private cache = new Map<string, CacheEntry>()

  async get<T>(key: string, fetcher: () => Promise<T>, ttl = 300000): Promise<T> {
    const cached = this.cache.get(key)
    
    if (cached && cached.expiresAt > Date.now()) {
      return cached.value
    }

    const value = await fetcher()
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttl
    })

    return value
  }
}
```

## üèóÔ∏è Architecture Patterns

### **Domain Separation Pattern**

```
lib/modassembly/
‚îú‚îÄ‚îÄ supabase/          # Database domain
‚îú‚îÄ‚îÄ openai/           # AI/ML domain  
‚îú‚îÄ‚îÄ audio-recording/  # Media domain
‚îî‚îÄ‚îÄ monitoring/       # Observability domain
```

### **Three-Tier Enhancement Pattern**

```typescript
// Foundation Tier
export function basicClient() { /* simple implementation */ }

// Production Tier (alongside Foundation)
export class OptimizedClient { /* enhanced implementation */ }

// Enterprise Tier (alongside both)
export class EnterpriseClient extends OptimizedClient { /* full features */ }
```

### **Factory Pattern for Tier Selection**

```typescript
export function createClient(tier: 'foundation' | 'production' | 'enterprise' = 'foundation') {
  switch (tier) {
    case 'foundation': return basicClient()
    case 'production': return new OptimizedClient()
    case 'enterprise': return new EnterpriseClient()
    default: return basicClient()
  }
}
```

## üîß Implementation Checklists

### **Basic Pattern Implementation**
- [ ] Add Modular Assembly file header
- [ ] Implement input sanitization
- [ ] Add value clamping for numeric inputs
- [ ] Include basic error handling
- [ ] Add performance monitoring wrapper

### **Security Enhancement**
- [ ] Validate all identifiers with regex
- [ ] Implement output sanitization
- [ ] Add audit logging for sensitive operations
- [ ] Configure demo user bypass system
- [ ] Test for injection vulnerabilities

### **Performance Optimization**
- [ ] Implement connection pooling
- [ ] Add retry logic with exponential backoff
- [ ] Configure intelligent caching
- [ ] Set up health monitoring
- [ ] Load test at target capacity

### **Enterprise Features**
- [ ] Deploy comprehensive monitoring
- [ ] Implement usage tracking
- [ ] Configure cost optimization
- [ ] Set up compliance logging
- [ ] Enable multi-tenant support (if needed)

## üö® Troubleshooting Quick Reference

### **Common Issues and Solutions**

| Issue | Pattern | Solution |
|-------|---------|----------|
| Input validation errors | Input Sanitization | Check `Security.sanitize.sanitizeInput()` implementation |
| Database connection issues | Connection Pooling | Verify pool size and health monitoring |
| Performance degradation | Performance Monitoring | Check `measureApiCall()` metrics |
| Demo user access denied | Demo User Bypass | Verify `isDemoUser()` function and environment settings |
| File modification conflicts | File Generation Header | Ensure proper Modular Assembly headers |

### **Debug Commands**

```bash
# Check security implementation
grep -r "Security.sanitize" lib/modassembly/

# Verify performance monitoring
grep -r "measureApiCall" lib/modassembly/

# Find demo user implementations
grep -r "isDemoUser" lib/modassembly/

# Check file headers
find lib/modassembly/ -name "*.ts" -exec head -3 {} \;
```

## üìà Performance Benchmarks

### **Expected Performance by Tier**

| Metric | Foundation | Production | Enterprise |
|--------|------------|------------|------------|
| Response Time (P95) | < 800ms | < 200ms | < 100ms |
| Throughput (RPS) | 100 | 1000 | 10000 |
| Error Rate | < 1% | < 0.1% | < 0.01% |
| Concurrent Users | 100 | 1000 | 10000+ |

### **Security Benchmarks**

| Security Feature | Implementation Status | Expected Impact |
|------------------|----------------------|-----------------|
| Input Validation | ‚úÖ All inputs | 99% injection prevention |
| Output Sanitization | ‚úÖ All outputs | 100% data leak prevention |
| Audit Logging | ‚úÖ All sensitive ops | Full compliance |
| Demo User System | ‚úÖ All permission checks | Development velocity +40% |

---

**Quick Start**: Begin with [File Generation Header](#file-generation-header) and [Input Sanitization](#input-sanitization) patterns
**Next Steps**: Review [`11-migration-strategy.md`](./11-migration-strategy.md) for systematic implementation
**Advanced Features**: See individual pattern documentation for enterprise implementations