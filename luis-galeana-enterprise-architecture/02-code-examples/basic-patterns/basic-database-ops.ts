/**
 * File generated by Modular Assembly - Foundation Tier
 * IMPORTANT!!! Ask the user before editing this file.
 */

import { createClient } from './basic-client'
import { Database } from '@/types/database'

/**
 * Foundation Tier: Basic Database Operations
 * 
 * Purpose: Simple CRUD operations for core entities
 * Suitable for: MVP development, basic data access
 * 
 * Features:
 * - Basic CRUD operations
 * - TypeScript integration
 * - Simple error handling
 * - Clean API
 */

type Order = Database['public']['Tables']['orders']['Row']
type OrderInsert = Database['public']['Tables']['orders']['Insert']
type OrderUpdate = Database['public']['Tables']['orders']['Update']

/**
 * Orders Operations
 */
export async function fetchOrders(limit = 10): Promise<Order[]> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('orders')
    .select('*')
    .order('created_at', { ascending: false })
    .limit(limit)

  if (error) {
    console.error('Error fetching orders:', error)
    throw new Error(`Failed to fetch orders: ${error.message}`)
  }

  return data || []
}

export async function fetchOrderById(id: string): Promise<Order | null> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('orders')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    console.error('Error fetching order:', error)
    throw new Error(`Failed to fetch order: ${error.message}`)
  }

  return data
}

export async function createOrder(order: OrderInsert): Promise<Order> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('orders')
    .insert(order)
    .select()
    .single()

  if (error) {
    console.error('Error creating order:', error)
    throw new Error(`Failed to create order: ${error.message}`)
  }

  return data
}

export async function updateOrder(id: string, updates: OrderUpdate): Promise<Order> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('orders')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) {
    console.error('Error updating order:', error)
    throw new Error(`Failed to update order: ${error.message}`)
  }

  return data
}

export async function deleteOrder(id: string): Promise<void> {
  const supabase = createClient()
  
  const { error } = await supabase
    .from('orders')
    .delete()
    .eq('id', id)

  if (error) {
    console.error('Error deleting order:', error)
    throw new Error(`Failed to delete order: ${error.message}`)
  }
}

/**
 * Tables Operations
 */
type Table = Database['public']['Tables']['tables']['Row']
type TableInsert = Database['public']['Tables']['tables']['Insert']

export async function fetchTables(): Promise<Table[]> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('tables')
    .select('*')
    .order('label', { ascending: true })

  if (error) {
    console.error('Error fetching tables:', error)
    throw new Error(`Failed to fetch tables: ${error.message}`)
  }

  return data || []
}

export async function createTable(table: TableInsert): Promise<Table> {
  const supabase = createClient()
  
  const { data, error } = await supabase
    .from('tables')
    .insert(table)
    .select()
    .single()

  if (error) {
    console.error('Error creating table:', error)
    throw new Error(`Failed to create table: ${error.message}`)
  }

  return data
}

/**
 * Real-time Subscriptions
 */
export function subscribeToOrders(
  callback: (payload: any) => void,
  filters?: { table_id?: string; status?: string }
) {
  const supabase = createClient()
  
  let query = supabase
    .channel('orders_changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'orders',
      },
      callback
    )

  return query.subscribe()
}

/**
 * Usage Examples:
 * 
 * // Fetch orders
 * const orders = await fetchOrders(20)
 * 
 * // Create new order
 * const newOrder = await createOrder({
 *   table_id: 'table-123',
 *   seat_id: 'seat-456',
 *   items: ['burger', 'fries'],
 *   status: 'pending'
 * })
 * 
 * // Subscribe to order changes
 * const subscription = subscribeToOrders((payload) => {
 *   console.log('Order changed:', payload)
 * })
 * 
 * // Clean up subscription
 * subscription.unsubscribe()
 */

/**
 * Benefits:
 * - Simple, clean API
 * - TypeScript integration
 * - Real-time subscriptions
 * - Error handling
 * 
 * Limitations:
 * - No input validation
 * - Basic error handling
 * - No performance monitoring
 * - No caching
 * - No batch operations
 */